
Audio_System.elf:     file format elf32-littlenios2
Audio_System.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000c0228

Program Header:
    LOAD off    0x00001000 vaddr 0x000c0000 paddr 0x000c0000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x000c0020 paddr 0x000c0020 align 2**12
         filesz 0x00004194 memsz 0x00004194 flags r-x
    LOAD off    0x000051b4 vaddr 0x000c41b4 paddr 0x000c4468 align 2**12
         filesz 0x000002b4 memsz 0x000002b4 flags rw-
    LOAD off    0x0000071c vaddr 0x000c471c paddr 0x000c471c align 2**12
         filesz 0x00000000 memsz 0x000001dc flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  000c0000  000c0000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000208  000c0020  000c0020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00003c98  000c0228  000c0228  00001228  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000002f4  000c3ec0  000c3ec0  00004ec0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000002b4  000c41b4  000c4468  000051b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000001dc  000c471c  000c471c  0000571c  2**2
                  ALLOC, SMALL_DATA
  6 .audio_rom    00000000  00000000  00000000  00005468  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  000c48f8  000c48f8  00005468  2**0
                  CONTENTS
  8 .comment      0000002d  00000000  00000000  00005468  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000006d0  00000000  00000000  00005498  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_info   000096b5  00000000  00000000  00005b68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 000037cb  00000000  00000000  0000f21d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line   00003106  00000000  00000000  000129e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  00001208  00000000  00000000  00015af0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00001d0a  00000000  00000000  00016cf8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_alt_sim_info 00000040  00000000  00000000  00018a04  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000070  00000000  00000000  00018a48  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00001099  00000000  00000000  00018ab8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00001183  00000000  00000000  00019b51  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000001e4  00000000  00000000  0001acd4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .thread_model 00000003  00000000  00000000  0001d386  2**0
                  CONTENTS, READONLY
 21 .cpu          0000000c  00000000  00000000  0001d389  2**0
                  CONTENTS, READONLY
 22 .qsys         00000001  00000000  00000000  0001d395  2**0
                  CONTENTS, READONLY
 23 .simulation_enabled 00000001  00000000  00000000  0001d396  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000000b  00000000  00000000  0001d397  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000000b  00000000  00000000  0001d3a2  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000000b  00000000  00000000  0001d3ad  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000c  00000000  00000000  0001d3b8  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000036  00000000  00000000  0001d3c4  2**0
                  CONTENTS, READONLY
 29 .jdi          0000531a  00000000  00000000  0001d3fa  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     0005cc85  00000000  00000000  00022714  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
000c0000 l    d  .entry	00000000 .entry
000c0020 l    d  .exceptions	00000000 .exceptions
000c0228 l    d  .text	00000000 .text
000c3ec0 l    d  .rodata	00000000 .rodata
000c41b4 l    d  .rwdata	00000000 .rwdata
000c471c l    d  .bss	00000000 .bss
00000000 l    d  .audio_rom	00000000 .audio_rom
000c48f8 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    df *ABS*	00000000 crt0.o
000c0260 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 vfprintf.c
000c0f68 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_load.c
000c1760 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
000c1ac8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
000c1c08 l     F .text	00000034 alt_dev_reg
000c4208 l     O .rwdata	0000002c jtag_uart_0
000c4234 l     O .rwdata	00000030 audio_config
000c4264 l     O .rwdata	00000030 audio
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
000c1f20 l     F .text	00000080 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_up_avalon_audio.c
00000000 l    df *ABS*	00000000 altera_up_avalon_audio_and_video_config.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
000c2ffc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
000c3134 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
000c3160 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
000c33bc l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
000c368c l     F .text	0000003c alt_get_errno
000c36c8 l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
000c4760 g     O .bss	00000004 alt_instruction_exception_handler
000c28f0 g     F .text	00000038 alt_up_av_config_reset
000c2d44 g     F .text	00000058 alt_up_av_config_read_D5M_cfg_register
000c2960 g     F .text	00000034 alt_up_av_config_disable_interrupt
000c184c g     F .text	0000007c alt_main
000c06f4 g     F .text	000002a4 initialize_audio
000c0ebc g     F .text	00000080 _puts_r
000c476c g     O .bss	00000100 alt_irq
000c4468 g       *ABS*	00000000 __flash_rwdata_start
000c22bc g     F .text	00000060 alt_up_audio_read_fifo_avail
000c2a20 g     F .text	000000a4 alt_up_av_config_write_audio_cfg_register
000c0e74 g     F .text	00000048 printf
000c231c g     F .text	00000068 alt_up_audio_record_r
000c2228 g     F .text	00000094 alt_up_audio_reset_audio_core
000c4724 g     O .bss	00000004 audio_playing
000c3974 g     F .text	00000024 altera_nios2_gen2_irq_init
000c0000 g     F .entry	0000000c __reset
000c4730 g     O .bss	00000004 buffer_underrun
000c4764 g     O .bss	00000004 __stdio_exit_handler
000c0020 g       *ABS*	00000000 __flash_exceptions_start
000c4740 g     O .bss	00000004 errno
000c21ec g     F .text	0000003c alt_up_audio_write_interrupt_pending
000c4748 g     O .bss	00000004 alt_argv
000cc43c g       *ABS*	00000000 _gp
000c1a98 g     F .text	00000030 usleep
000c42bc g     O .rwdata	00000180 alt_fd_list
000c330c g     F .text	00000090 alt_find_dev
000c3490 g     F .text	0000007c alt_io_redirect
000c3ec0 g       *ABS*	00000000 __DTOR_END__
000c0f3c g     F .text	00000010 puts
000c3b58 g     F .text	00000074 alt_exception_cause_generated_bad_addr
000c26f4 g     F .text	00000050 alt_up_audio_read_fifo_head
000c1d9c g     F .text	000000ec altera_avalon_jtag_uart_read
000c0e38 g     F .text	0000003c _printf_r
000c0000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
000c0d50 g     F .text	00000064 .hidden __udivsi3
000c2870 g     F .text	00000080 alt_up_av_config_read_data
000c471c g     O .bss	00000004 audio_dev
000c445c g     O .rwdata	00000004 alt_max_fd
000c2744 g     F .text	00000068 alt_up_audio_write_fifo_head
000c350c g     F .text	00000180 alt_irq_register
000c48f8 g       *ABS*	00000000 __bss_end
000c196c g     F .text	0000012c alt_tick
000c4738 g     O .bss	00000004 last_button_state
000c201c g     F .text	0000003c alt_up_audio_open_dev
000c244c g     F .text	00000068 alt_up_audio_play_r
000c18c8 g     F .text	000000a4 alt_alarm_stop
000c475c g     O .bss	00000004 alt_irq_active
000c00fc g     F .exceptions	000000cc alt_irq_handler
000c4294 g     O .rwdata	00000028 alt_dev_null
000c3114 g     F .text	00000020 alt_dcache_flush_all
000c4468 g       *ABS*	00000000 __ram_rwdata_end
000c0c2c g     F .text	00000030 update_leds
000c4454 g     O .rwdata	00000008 alt_dev_list
000c1b04 g     F .text	00000104 write
000c41b4 g       *ABS*	00000000 __ram_rodata_end
000c0db4 g     F .text	0000005c .hidden __umodsi3
000c48f8 g       *ABS*	00000000 end
000c01c8 g     F .exceptions	00000060 alt_instruction_exception_entry
000c3ec0 g       *ABS*	00000000 __CTOR_LIST__
000c7ffc g       *ABS*	00000000 __alt_stack_pointer
000c473c g     O .bss	00000004 muted
000c1fa0 g     F .text	0000007c alt_avalon_timer_sc_init
000c1e88 g     F .text	00000098 altera_avalon_jtag_uart_write
000c0fd4 g     F .text	0000051c ___vfprintf_internal_r
000c0998 g     F .text	000001f4 process_audio_buffer
000c3d58 g     F .text	0000012c __call_exitprocs
000c486c g     O .bss	0000008c __atexit0
000c0228 g     F .text	0000003c _start
000c4750 g     O .bss	00000004 _alt_tick_rate
000c25fc g     F .text	000000f8 alt_up_audio_write_fifo
000c280c g     F .text	00000064 alt_up_av_config_write_data
000c4754 g     O .bss	00000008 _alt_nticks
000c1c78 g     F .text	00000064 alt_sys_init
000c251c g     F .text	000000e0 alt_up_audio_read_fifo
000c3c30 g     F .text	00000128 __register_exitproc
000c2e4c g     F .text	00000058 alt_up_av_config_write_LTM_cfg_register
000c2158 g     F .text	00000058 alt_up_audio_disable_write_interrupt
000c0e10 g     F .text	00000028 .hidden __mulsi3
000c41b4 g       *ABS*	00000000 __ram_rwdata_start
000c3ec0 g       *ABS*	00000000 __ram_rodata_start
000c1cdc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
000c3aa0 g     F .text	000000b8 alt_get_fd
000c2ea4 g     F .text	00000158 alt_busy_sleep
000c2104 g     F .text	00000054 alt_up_audio_enable_write_interrupt
000c3c00 g     F .text	00000030 memcmp
000c48f8 g       *ABS*	00000000 __alt_stack_base
000c20ac g     F .text	00000058 alt_up_audio_disable_read_interrupt
000c4768 g     O .bss	00000004 __atexit
000c3998 g     F .text	00000108 alt_find_file
000c319c g     F .text	000000a8 alt_dev_llist_insert
000c1508 g     F .text	000000a8 __sfvwrite_small_dev
000c471c g       *ABS*	00000000 __bss_start
000c0264 g     F .text	000003a4 main
000c23ec g     F .text	00000060 alt_up_audio_write_fifo_space
000c474c g     O .bss	00000004 alt_envp
000c1d3c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
000c472c g     O .bss	00000004 audio_loop
000c4460 g     O .rwdata	00000004 alt_errno
000c4728 g     O .bss	00000004 audio_position
000c0c5c g     F .text	00000080 .hidden __divsi3
000c3ec0 g       *ABS*	00000000 __CTOR_END__
000c0b8c g     F .text	00000064 handle_audio_interrupt
000c3ec0 g       *ABS*	00000000 __flash_rodata_start
000c3ec0 g       *ABS*	00000000 __DTOR_LIST__
000c27ac g     F .text	00000060 alt_up_av_config_open_dev
000c1c3c g     F .text	0000003c alt_irq_init
000c3904 g     F .text	00000070 alt_release_fd
000c4720 g     O .bss	00000004 av_config
00000000 g       *ABS*	00000000 __alt_mem_audio_rom
000c3bcc g     F .text	00000014 atexit
000c15b0 g     F .text	00000050 _write_r
000c29e8 g     F .text	00000038 alt_up_av_config_read_ready
000c4440 g     O .rwdata	00000004 _impure_ptr
000c4744 g     O .bss	00000004 alt_argc
000c32a8 g     F .text	00000064 _do_dtors
000c0020 g       .exceptions	00000000 alt_irq_entry
000c444c g     O .rwdata	00000008 alt_fs_list
000c2384 g     F .text	00000068 alt_up_audio_record_l
000c0020 g       *ABS*	00000000 __ram_exceptions_start
000c2928 g     F .text	00000038 alt_up_av_config_enable_interrupt
000c2994 g     F .text	00000054 alt_up_av_config_read_acknowledge
000c2cec g     F .text	00000058 alt_up_av_config_write_DC2_cfg_register
000c4468 g       *ABS*	00000000 _edata
000c48f8 g       *ABS*	00000000 _end
000c0228 g       *ABS*	00000000 __ram_exceptions_end
000c24b4 g     F .text	00000068 alt_up_audio_play_l
000c3be0 g     F .text	00000020 exit
000c2df4 g     F .text	00000058 alt_up_av_config_read_LTM_cfg_register
000c0cdc g     F .text	00000074 .hidden __modsi3
000c41b4 g     O .rwdata	00000054 _impure_data
000c7ffc g       *ABS*	00000000 __alt_data_end
000c0020 g     F .exceptions	00000000 alt_exception
000c0608 g     F .text	00000084 set_headphone_volume
000c3e84 g     F .text	0000003c _exit
000c0bf0 g     F .text	0000003c timer_isr
000c1600 g     F .text	00000160 alt_alarm_start
000c0f4c g     F .text	0000001c strlen
000c37a4 g     F .text	00000160 open
000c2ac4 g     F .text	000000e8 alt_up_av_config_read_video_cfg_register
000c339c g     F .text	00000020 alt_icache_flush_all
000c4464 g     O .rwdata	00000004 alt_priority_mask
000c14f0 g     F .text	00000018 __vfprintf_internal
000c443c g     O .rwdata	00000004 headphone_volume
000c2d9c g     F .text	00000058 alt_up_av_config_write_D5M_cfg_register
000c4734 g     O .bss	00000004 last_switch_state
000c4444 g     O .rwdata	00000008 alt_alarm_list
000c3244 g     F .text	00000064 _do_ctors
000c068c g     F .text	00000068 toggle_mute
000c3038 g     F .text	000000dc close
000c17c8 g     F .text	00000084 alt_load
000c2058 g     F .text	00000054 alt_up_audio_enable_read_interrupt
000c2bac g     F .text	000000e8 alt_up_av_config_write_video_cfg_register
000c2c94 g     F .text	00000058 alt_up_av_config_read_DC2_cfg_register
000c21b0 g     F .text	0000003c alt_up_audio_read_interrupt_pending



Disassembly of section .entry:

000c0000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   c0000:	00400334 	movhi	at,12
    ori r1, r1, %lo(_start)
   c0004:	08408a14 	ori	at,at,552
    jmp r1
   c0008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

000c0020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   c0020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   c0024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   c0028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   c002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   c0030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   c0034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   c0038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   c003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   c0040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   c0044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   c0048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   c004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   c0050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   c0054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   c0058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   c005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   c0060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   c0064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   c0068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   c006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   c0070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   c0074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   c0078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   c007c:	10000326 	beq	r2,zero,c008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   c0080:	20000226 	beq	r4,zero,c008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   c0084:	00c00fc0 	call	c00fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   c0088:	00000706 	br	c00a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   c008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   c0090:	e8bfff17 	ldw	r2,-4(ea)
   c0094:	e93fff04 	addi	r4,ea,-4
   c0098:	00c01c80 	call	c01c8 <alt_instruction_exception_entry>
   c009c:	1000021e 	bne	r2,zero,c00a8 <alt_exception+0x88>
   c00a0:	ebffff04 	addi	r15,ea,-4
   c00a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   c00a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   c00ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   c00b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   c00b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   c00b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   c00bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   c00c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   c00c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   c00c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   c00cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   c00d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   c00d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   c00d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   c00dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   c00e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   c00e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   c00e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   c00ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   c00f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   c00f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   c00f8:	ef80083a 	eret

000c00fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   c00fc:	defff904 	addi	sp,sp,-28
   c0100:	dfc00615 	stw	ra,24(sp)
   c0104:	df000515 	stw	fp,20(sp)
   c0108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   c010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   c0110:	0005313a 	rdctl	r2,ipending
   c0114:	e0bffc15 	stw	r2,-16(fp)

  return active;
   c0118:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   c011c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
   c0120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   c0124:	00800044 	movi	r2,1
   c0128:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   c012c:	e0ffff17 	ldw	r3,-4(fp)
   c0130:	e0bffe17 	ldw	r2,-8(fp)
   c0134:	1884703a 	and	r2,r3,r2
   c0138:	10001226 	beq	r2,zero,c0184 <alt_irq_handler+0x88>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
   c013c:	e0bffd17 	ldw	r2,-12(fp)
   c0140:	100690fa 	slli	r3,r2,3
   c0144:	00800334 	movhi	r2,12
   c0148:	1885883a 	add	r2,r3,r2
   c014c:	10d1db17 	ldw	r3,18284(r2)
   c0150:	e0bffd17 	ldw	r2,-12(fp)
   c0154:	100890fa 	slli	r4,r2,3
   c0158:	00800334 	movhi	r2,12
   c015c:	2085883a 	add	r2,r4,r2
   c0160:	1091dc17 	ldw	r2,18288(r2)
   c0164:	e17ffd17 	ldw	r5,-12(fp)
   c0168:	1009883a 	mov	r4,r2
   c016c:	183ee83a 	callr	r3
#endif
        break;
   c0170:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
   c0174:	0005313a 	rdctl	r2,ipending
   c0178:	e0bffb15 	stw	r2,-20(fp)
  return active;
   c017c:	e0bffb17 	ldw	r2,-20(fp)
   c0180:	00000706 	br	c01a0 <alt_irq_handler+0xa4>
      }
      mask <<= 1;
   c0184:	e0bffe17 	ldw	r2,-8(fp)
   c0188:	1085883a 	add	r2,r2,r2
   c018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
   c0190:	e0bffd17 	ldw	r2,-12(fp)
   c0194:	10800044 	addi	r2,r2,1
   c0198:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
   c019c:	003fe306 	br	c012c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
   c01a0:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
   c01a4:	e0bfff17 	ldw	r2,-4(fp)
   c01a8:	103fdd1e 	bne	r2,zero,c0120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   c01ac:	0001883a 	nop
}
   c01b0:	0001883a 	nop
   c01b4:	e037883a 	mov	sp,fp
   c01b8:	dfc00117 	ldw	ra,4(sp)
   c01bc:	df000017 	ldw	fp,0(sp)
   c01c0:	dec00204 	addi	sp,sp,8
   c01c4:	f800283a 	ret

000c01c8 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   c01c8:	defffb04 	addi	sp,sp,-20
   c01cc:	dfc00415 	stw	ra,16(sp)
   c01d0:	df000315 	stw	fp,12(sp)
   c01d4:	df000304 	addi	fp,sp,12
   c01d8:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
   c01dc:	00bfffc4 	movi	r2,-1
   c01e0:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
   c01e4:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   c01e8:	d0a0c917 	ldw	r2,-31964(gp)
   c01ec:	10000726 	beq	r2,zero,c020c <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   c01f0:	d0a0c917 	ldw	r2,-31964(gp)
   c01f4:	e0ffff17 	ldw	r3,-4(fp)
   c01f8:	e1bffe17 	ldw	r6,-8(fp)
   c01fc:	e17ffd17 	ldw	r5,-12(fp)
   c0200:	1809883a 	mov	r4,r3
   c0204:	103ee83a 	callr	r2
   c0208:	00000206 	br	c0214 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   c020c:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
   c0210:	0005883a 	mov	r2,zero
}
   c0214:	e037883a 	mov	sp,fp
   c0218:	dfc00117 	ldw	ra,4(sp)
   c021c:	df000017 	ldw	fp,0(sp)
   c0220:	dec00204 	addi	sp,sp,8
   c0224:	f800283a 	ret

Disassembly of section .text:

000c0228 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   c0228:	06c00334 	movhi	sp,12
    ori sp, sp, %lo(__alt_stack_pointer)
   c022c:	dedfff14 	ori	sp,sp,32764
    movhi gp, %hi(_gp)
   c0230:	06800334 	movhi	gp,12
    ori gp, gp, %lo(_gp)
   c0234:	d6b10f14 	ori	gp,gp,50236
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   c0238:	00800334 	movhi	r2,12
    ori r2, r2, %lo(__bss_start)
   c023c:	1091c714 	ori	r2,r2,18204

    movhi r3, %hi(__bss_end)
   c0240:	00c00334 	movhi	r3,12
    ori r3, r3, %lo(__bss_end)
   c0244:	18d23e14 	ori	r3,r3,18680

    beq r2, r3, 1f
   c0248:	10c00326 	beq	r2,r3,c0258 <_start+0x30>

0:
    stw zero, (r2)
   c024c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   c0250:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   c0254:	10fffd36 	bltu	r2,r3,c024c <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   c0258:	00c17c80 	call	c17c8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   c025c:	00c184c0 	call	c184c <alt_main>

000c0260 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   c0260:	003fff06 	br	c0260 <alt_after_alt_main>

000c0264 <main>:
void process_audio_buffer(void);
void set_headphone_volume(int volume);
void toggle_mute(void);

// Main function
int main(void) {
   c0264:	defff504 	addi	sp,sp,-44
   c0268:	dfc00a15 	stw	ra,40(sp)
   c026c:	df000915 	stw	fp,36(sp)
   c0270:	df000904 	addi	fp,sp,36
    printf("Audio Playback Application Starting\n");
   c0274:	01000334 	movhi	r4,12
   c0278:	210fb004 	addi	r4,r4,16064
   c027c:	00c0f3c0 	call	c0f3c <puts>

    // Initialize status
    update_leds(LED_INIT);
   c0280:	01000044 	movi	r4,1
   c0284:	00c0c2c0 	call	c0c2c <update_leds>

    // Initialize audio codec
    if (initialize_audio() != 0) {
   c0288:	00c06f40 	call	c06f4 <initialize_audio>
   c028c:	10000726 	beq	r2,zero,c02ac <main+0x48>
        printf("Audio initialization failed\n");
   c0290:	01000334 	movhi	r4,12
   c0294:	210fb904 	addi	r4,r4,16100
   c0298:	00c0f3c0 	call	c0f3c <puts>
        update_leds(LED_ERROR);
   c029c:	01002004 	movi	r4,128
   c02a0:	00c0c2c0 	call	c0c2c <update_leds>
        return -1;
   c02a4:	00bfffc4 	movi	r2,-1
   c02a8:	0000d206 	br	c05f4 <main+0x390>
    }

    update_leds(LED_CONFIG_DONE);
   c02ac:	01000084 	movi	r4,2
   c02b0:	00c0c2c0 	call	c0c2c <update_leds>
    printf("Audio configuration successful\n");
   c02b4:	01000334 	movhi	r4,12
   c02b8:	210fc004 	addi	r4,r4,16128
   c02bc:	00c0f3c0 	call	c0f3c <puts>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   c02c0:	d0a0c517 	ldw	r2,-31980(gp)

    // Setup timer for periodic processing (100ms)
    alt_alarm timer;
    alt_alarm_start(&timer, alt_ticks_per_second()/10, timer_isr, NULL);
   c02c4:	01400284 	movi	r5,10
   c02c8:	1009883a 	mov	r4,r2
   c02cc:	00c0d500 	call	c0d50 <__udivsi3>
   c02d0:	1007883a 	mov	r3,r2
   c02d4:	e0bff704 	addi	r2,fp,-36
   c02d8:	000f883a 	mov	r7,zero
   c02dc:	01800334 	movhi	r6,12
   c02e0:	3182fc04 	addi	r6,r6,3056
   c02e4:	180b883a 	mov	r5,r3
   c02e8:	1009883a 	mov	r4,r2
   c02ec:	00c16000 	call	c1600 <alt_alarm_start>

    // Fill buffers initially to prevent underrun
    process_audio_buffer();
   c02f0:	00c09980 	call	c0998 <process_audio_buffer>
    audio_playing = 1;
   c02f4:	00800044 	movi	r2,1
   c02f8:	d0a0ba15 	stw	r2,-32024(gp)
    update_leds(LED_PLAYING);
   c02fc:	01000104 	movi	r4,4
   c0300:	00c0c2c0 	call	c0c2c <update_leds>
    printf("Audio playback started\n");
   c0304:	01000334 	movhi	r4,12
   c0308:	210fc804 	addi	r4,r4,16160
   c030c:	00c0f3c0 	call	c0f3c <puts>

    // Main application loop
    while (1) {
        // Read switch status
        unsigned int switches = IORD_ALTERA_AVALON_PIO_DATA(SWITCH_PIO_BASE);
   c0310:	00800434 	movhi	r2,16
   c0314:	10840c37 	ldwio	r2,4144(r2)
   c0318:	e0bffe15 	stw	r2,-8(fp)
        unsigned int buttons = IORD_ALTERA_AVALON_PIO_DATA(KEY_PIO_BASE);
   c031c:	00800434 	movhi	r2,16
   c0320:	10840837 	ldwio	r2,4128(r2)
   c0324:	e0bffd15 	stw	r2,-12(fp)

        // Invert button values since they are active-low
        buttons = ~buttons & 0xF;
   c0328:	e0bffd17 	ldw	r2,-12(fp)
   c032c:	0084303a 	nor	r2,zero,r2
   c0330:	108003cc 	andi	r2,r2,15
   c0334:	e0bffd15 	stw	r2,-12(fp)

        // Process switches if changed
        if (switches != last_switch_state) {
   c0338:	d0a0be17 	ldw	r2,-32008(gp)
   c033c:	e0fffe17 	ldw	r3,-8(fp)
   c0340:	18808b26 	beq	r3,r2,c0570 <main+0x30c>
            int status_led = (audio_playing ? LED_PLAYING : LED_PAUSED);
   c0344:	d0a0ba17 	ldw	r2,-32024(gp)
   c0348:	10000226 	beq	r2,zero,c0354 <main+0xf0>
   c034c:	00800104 	movi	r2,4
   c0350:	00000106 	br	c0358 <main+0xf4>
   c0354:	00800204 	movi	r2,8
   c0358:	e0bfff15 	stw	r2,-4(fp)

            // Play/Pause control (SW0)
            if ((switches & SW_PLAY_PAUSE) != (last_switch_state & SW_PLAY_PAUSE)) {
   c035c:	d0e0be17 	ldw	r3,-32008(gp)
   c0360:	e0bffe17 	ldw	r2,-8(fp)
   c0364:	1884f03a 	xor	r2,r3,r2
   c0368:	1080004c 	andi	r2,r2,1
   c036c:	10001426 	beq	r2,zero,c03c0 <main+0x15c>
                if (switches & SW_PLAY_PAUSE) {
   c0370:	e0bffe17 	ldw	r2,-8(fp)
   c0374:	1080004c 	andi	r2,r2,1
   c0378:	10001126 	beq	r2,zero,c03c0 <main+0x15c>
                    audio_playing = !audio_playing;
   c037c:	d0a0ba17 	ldw	r2,-32024(gp)
   c0380:	1005003a 	cmpeq	r2,r2,zero
   c0384:	10803fcc 	andi	r2,r2,255
   c0388:	d0a0ba15 	stw	r2,-32024(gp)
                    if (audio_playing) {
   c038c:	d0a0ba17 	ldw	r2,-32024(gp)
   c0390:	10000626 	beq	r2,zero,c03ac <main+0x148>
                        printf("Audio playback started\n");
   c0394:	01000334 	movhi	r4,12
   c0398:	210fc804 	addi	r4,r4,16160
   c039c:	00c0f3c0 	call	c0f3c <puts>
                        status_led = LED_PLAYING;
   c03a0:	00800104 	movi	r2,4
   c03a4:	e0bfff15 	stw	r2,-4(fp)
   c03a8:	00000506 	br	c03c0 <main+0x15c>
                    } else {
                        printf("Audio playback paused\n");
   c03ac:	01000334 	movhi	r4,12
   c03b0:	210fce04 	addi	r4,r4,16184
   c03b4:	00c0f3c0 	call	c0f3c <puts>
                        status_led = LED_PAUSED;
   c03b8:	00800204 	movi	r2,8
   c03bc:	e0bfff15 	stw	r2,-4(fp)
                    }
                }
            }

            // Restart control (SW1)
            if ((switches & SW_RESTART) != (last_switch_state & SW_RESTART)) {
   c03c0:	d0e0be17 	ldw	r3,-32008(gp)
   c03c4:	e0bffe17 	ldw	r2,-8(fp)
   c03c8:	1884f03a 	xor	r2,r3,r2
   c03cc:	1080008c 	andi	r2,r2,2
   c03d0:	10000726 	beq	r2,zero,c03f0 <main+0x18c>
                if (switches & SW_RESTART) {
   c03d4:	e0bffe17 	ldw	r2,-8(fp)
   c03d8:	1080008c 	andi	r2,r2,2
   c03dc:	10000426 	beq	r2,zero,c03f0 <main+0x18c>
                    audio_position = 0;
   c03e0:	d020bb15 	stw	zero,-32020(gp)
                    printf("Audio playback restarted\n");
   c03e4:	01000334 	movhi	r4,12
   c03e8:	210fd404 	addi	r4,r4,16208
   c03ec:	00c0f3c0 	call	c0f3c <puts>
                }
            }

            // Loop control (SW2)
            if ((switches & SW_LOOP) != (last_switch_state & SW_LOOP)) {
   c03f0:	d0e0be17 	ldw	r3,-32008(gp)
   c03f4:	e0bffe17 	ldw	r2,-8(fp)
   c03f8:	1884f03a 	xor	r2,r3,r2
   c03fc:	1080010c 	andi	r2,r2,4
   c0400:	10000f26 	beq	r2,zero,c0440 <main+0x1dc>
                audio_loop = (switches & SW_LOOP) ? 1 : 0;
   c0404:	e0bffe17 	ldw	r2,-8(fp)
   c0408:	1004d0ba 	srli	r2,r2,2
   c040c:	1080004c 	andi	r2,r2,1
   c0410:	d0a0bc15 	stw	r2,-32016(gp)
                printf("Audio loop %s\n", audio_loop ? "enabled" : "disabled");
   c0414:	d0a0bc17 	ldw	r2,-32016(gp)
   c0418:	10000326 	beq	r2,zero,c0428 <main+0x1c4>
   c041c:	00800334 	movhi	r2,12
   c0420:	108fdb04 	addi	r2,r2,16236
   c0424:	00000206 	br	c0430 <main+0x1cc>
   c0428:	00800334 	movhi	r2,12
   c042c:	108fdd04 	addi	r2,r2,16244
   c0430:	100b883a 	mov	r5,r2
   c0434:	01000334 	movhi	r4,12
   c0438:	210fe004 	addi	r4,r4,16256
   c043c:	00c0e740 	call	c0e74 <printf>
            }

            // Volume Up (SW3)
            if ((switches & SW_VOL_UP) != (last_switch_state & SW_VOL_UP)) {
   c0440:	d0e0be17 	ldw	r3,-32008(gp)
   c0444:	e0bffe17 	ldw	r2,-8(fp)
   c0448:	1884f03a 	xor	r2,r3,r2
   c044c:	1080020c 	andi	r2,r2,8
   c0450:	10001f26 	beq	r2,zero,c04d0 <main+0x26c>
                if (switches & SW_VOL_UP) {
   c0454:	e0bffe17 	ldw	r2,-8(fp)
   c0458:	1080020c 	andi	r2,r2,8
   c045c:	10001c26 	beq	r2,zero,c04d0 <main+0x26c>
                    if (headphone_volume < MAX_HEADPHONE_VOLUME) {
   c0460:	d0a00017 	ldw	r2,-32768(gp)
   c0464:	10801fc8 	cmpgei	r2,r2,127
   c0468:	1000191e 	bne	r2,zero,c04d0 <main+0x26c>
                        headphone_volume += VOLUME_STEP;
   c046c:	d0a00017 	ldw	r2,-32768(gp)
   c0470:	10800104 	addi	r2,r2,4
   c0474:	d0a00015 	stw	r2,-32768(gp)
                        if (headphone_volume > MAX_HEADPHONE_VOLUME) {
   c0478:	d0a00017 	ldw	r2,-32768(gp)
   c047c:	10802010 	cmplti	r2,r2,128
   c0480:	1000021e 	bne	r2,zero,c048c <main+0x228>
                            headphone_volume = MAX_HEADPHONE_VOLUME;
   c0484:	00801fc4 	movi	r2,127
   c0488:	d0a00015 	stw	r2,-32768(gp)
                        }
                        set_headphone_volume(headphone_volume);
   c048c:	d0a00017 	ldw	r2,-32768(gp)
   c0490:	1009883a 	mov	r4,r2
   c0494:	00c06080 	call	c0608 <set_headphone_volume>
                        printf("Volume increased to %d%%\n", (headphone_volume * 100) / MAX_HEADPHONE_VOLUME);
   c0498:	d0a00017 	ldw	r2,-32768(gp)
   c049c:	01401904 	movi	r5,100
   c04a0:	1009883a 	mov	r4,r2
   c04a4:	00c0e100 	call	c0e10 <__mulsi3>
   c04a8:	01401fc4 	movi	r5,127
   c04ac:	1009883a 	mov	r4,r2
   c04b0:	00c0c5c0 	call	c0c5c <__divsi3>
   c04b4:	100b883a 	mov	r5,r2
   c04b8:	01000334 	movhi	r4,12
   c04bc:	210fe404 	addi	r4,r4,16272
   c04c0:	00c0e740 	call	c0e74 <printf>
                        status_led |= LED_VOL_CHANGE;
   c04c4:	e0bfff17 	ldw	r2,-4(fp)
   c04c8:	10800414 	ori	r2,r2,16
   c04cc:	e0bfff15 	stw	r2,-4(fp)
                    }
                }
            }

            // Volume Down (SW4)
            if ((switches & SW_VOL_DOWN) != (last_switch_state & SW_VOL_DOWN)) {
   c04d0:	d0e0be17 	ldw	r3,-32008(gp)
   c04d4:	e0bffe17 	ldw	r2,-8(fp)
   c04d8:	1884f03a 	xor	r2,r3,r2
   c04dc:	1080040c 	andi	r2,r2,16
   c04e0:	10001f26 	beq	r2,zero,c0560 <main+0x2fc>
                if (switches & SW_VOL_DOWN) {
   c04e4:	e0bffe17 	ldw	r2,-8(fp)
   c04e8:	1080040c 	andi	r2,r2,16
   c04ec:	10001c26 	beq	r2,zero,c0560 <main+0x2fc>
                    if (headphone_volume > MIN_HEADPHONE_VOLUME) {
   c04f0:	d0a00017 	ldw	r2,-32768(gp)
   c04f4:	10800c50 	cmplti	r2,r2,49
   c04f8:	1000191e 	bne	r2,zero,c0560 <main+0x2fc>
                        headphone_volume -= VOLUME_STEP;
   c04fc:	d0a00017 	ldw	r2,-32768(gp)
   c0500:	10bfff04 	addi	r2,r2,-4
   c0504:	d0a00015 	stw	r2,-32768(gp)
                        if (headphone_volume < MIN_HEADPHONE_VOLUME) {
   c0508:	d0a00017 	ldw	r2,-32768(gp)
   c050c:	10800c08 	cmpgei	r2,r2,48
   c0510:	1000021e 	bne	r2,zero,c051c <main+0x2b8>
                            headphone_volume = MIN_HEADPHONE_VOLUME;
   c0514:	00800c04 	movi	r2,48
   c0518:	d0a00015 	stw	r2,-32768(gp)
                        }
                        set_headphone_volume(headphone_volume);
   c051c:	d0a00017 	ldw	r2,-32768(gp)
   c0520:	1009883a 	mov	r4,r2
   c0524:	00c06080 	call	c0608 <set_headphone_volume>
                        printf("Volume decreased to %d%%\n", (headphone_volume * 100) / MAX_HEADPHONE_VOLUME);
   c0528:	d0a00017 	ldw	r2,-32768(gp)
   c052c:	01401904 	movi	r5,100
   c0530:	1009883a 	mov	r4,r2
   c0534:	00c0e100 	call	c0e10 <__mulsi3>
   c0538:	01401fc4 	movi	r5,127
   c053c:	1009883a 	mov	r4,r2
   c0540:	00c0c5c0 	call	c0c5c <__divsi3>
   c0544:	100b883a 	mov	r5,r2
   c0548:	01000334 	movhi	r4,12
   c054c:	210feb04 	addi	r4,r4,16300
   c0550:	00c0e740 	call	c0e74 <printf>
                        status_led |= LED_VOL_CHANGE;
   c0554:	e0bfff17 	ldw	r2,-4(fp)
   c0558:	10800414 	ori	r2,r2,16
   c055c:	e0bfff15 	stw	r2,-4(fp)
                    }
                }
            }

            update_leds(status_led);
   c0560:	e13fff17 	ldw	r4,-4(fp)
   c0564:	00c0c2c0 	call	c0c2c <update_leds>
            last_switch_state = switches;
   c0568:	e0bffe17 	ldw	r2,-8(fp)
   c056c:	d0a0be15 	stw	r2,-32008(gp)
        }

        // Process buttons if changed
        if (buttons != last_button_state) {
   c0570:	d0a0bf17 	ldw	r2,-32004(gp)
   c0574:	e0fffd17 	ldw	r3,-12(fp)
   c0578:	18801426 	beq	r3,r2,c05cc <main+0x368>
            // Mute/Unmute (KEY1)
            if ((buttons & BTN_MUTE) && !(last_button_state & BTN_MUTE)) {
   c057c:	e0bffd17 	ldw	r2,-12(fp)
   c0580:	1080008c 	andi	r2,r2,2
   c0584:	10000f26 	beq	r2,zero,c05c4 <main+0x360>
   c0588:	d0a0bf17 	ldw	r2,-32004(gp)
   c058c:	1080008c 	andi	r2,r2,2
   c0590:	10000c1e 	bne	r2,zero,c05c4 <main+0x360>
                toggle_mute();
   c0594:	00c068c0 	call	c068c <toggle_mute>
                printf("Audio %s\n", muted ? "muted" : "unmuted");
   c0598:	d0a0c017 	ldw	r2,-32000(gp)
   c059c:	10000326 	beq	r2,zero,c05ac <main+0x348>
   c05a0:	00800334 	movhi	r2,12
   c05a4:	108ff204 	addi	r2,r2,16328
   c05a8:	00000206 	br	c05b4 <main+0x350>
   c05ac:	00800334 	movhi	r2,12
   c05b0:	108ff404 	addi	r2,r2,16336
   c05b4:	100b883a 	mov	r5,r2
   c05b8:	01000334 	movhi	r4,12
   c05bc:	210ff604 	addi	r4,r4,16344
   c05c0:	00c0e740 	call	c0e74 <printf>
            }

            last_button_state = buttons;
   c05c4:	e0bffd17 	ldw	r2,-12(fp)
   c05c8:	d0a0bf15 	stw	r2,-32004(gp)
        }

        // Check for buffer underrun
        if (buffer_underrun) {
   c05cc:	d0a0bd17 	ldw	r2,-32012(gp)
   c05d0:	10000526 	beq	r2,zero,c05e8 <main+0x384>
            printf("Buffer underrun detected, refilling...\n");
   c05d4:	01000334 	movhi	r4,12
   c05d8:	210ff904 	addi	r4,r4,16356
   c05dc:	00c0f3c0 	call	c0f3c <puts>
            process_audio_buffer();
   c05e0:	00c09980 	call	c0998 <process_audio_buffer>
            buffer_underrun = 0;
   c05e4:	d020bd15 	stw	zero,-32012(gp)
        }

        // Sleep to reduce CPU usage
        usleep(10000);
   c05e8:	0109c404 	movi	r4,10000
   c05ec:	00c1a980 	call	c1a98 <usleep>
    while (1) {
   c05f0:	003f4706 	br	c0310 <main+0xac>
    }

    return 0;
}
   c05f4:	e037883a 	mov	sp,fp
   c05f8:	dfc00117 	ldw	ra,4(sp)
   c05fc:	df000017 	ldw	fp,0(sp)
   c0600:	dec00204 	addi	sp,sp,8
   c0604:	f800283a 	ret

000c0608 <set_headphone_volume>:

// Set headphone output volume
void set_headphone_volume(int volume) {
   c0608:	defffc04 	addi	sp,sp,-16
   c060c:	dfc00315 	stw	ra,12(sp)
   c0610:	df000215 	stw	fp,8(sp)
   c0614:	df000204 	addi	fp,sp,8
   c0618:	e13ffe15 	stw	r4,-8(fp)
    // Ensure volume is within valid range
    if (volume < MIN_HEADPHONE_VOLUME || volume > MAX_HEADPHONE_VOLUME) {
   c061c:	e0bffe17 	ldw	r2,-8(fp)
   c0620:	10800c10 	cmplti	r2,r2,48
   c0624:	1000131e 	bne	r2,zero,c0674 <set_headphone_volume+0x6c>
   c0628:	e0bffe17 	ldw	r2,-8(fp)
   c062c:	10802010 	cmplti	r2,r2,128
   c0630:	10001026 	beq	r2,zero,c0674 <set_headphone_volume+0x6c>
        return;
    }

    // Set volume with zero crossing detection enabled (bit 7 set)
    int reg_data = volume | 0x80;  // Enable zero-crossing detection
   c0634:	e0bffe17 	ldw	r2,-8(fp)
   c0638:	10802014 	ori	r2,r2,128
   c063c:	e0bfff15 	stw	r2,-4(fp)

    // Update both left and right channels
    alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_LEFT_HEADPHONE_OUT, reg_data);
   c0640:	d0a0b917 	ldw	r2,-32028(gp)
   c0644:	e0ffff17 	ldw	r3,-4(fp)
   c0648:	180d883a 	mov	r6,r3
   c064c:	01400084 	movi	r5,2
   c0650:	1009883a 	mov	r4,r2
   c0654:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
    alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_RIGHT_HEADPHONE_OUT, reg_data);
   c0658:	d0a0b917 	ldw	r2,-32028(gp)
   c065c:	e0ffff17 	ldw	r3,-4(fp)
   c0660:	180d883a 	mov	r6,r3
   c0664:	014000c4 	movi	r5,3
   c0668:	1009883a 	mov	r4,r2
   c066c:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0670:	00000106 	br	c0678 <set_headphone_volume+0x70>
        return;
   c0674:	0001883a 	nop
}
   c0678:	e037883a 	mov	sp,fp
   c067c:	dfc00117 	ldw	ra,4(sp)
   c0680:	df000017 	ldw	fp,0(sp)
   c0684:	dec00204 	addi	sp,sp,8
   c0688:	f800283a 	ret

000c068c <toggle_mute>:

// Toggle mute state
void toggle_mute(void) {
   c068c:	defffd04 	addi	sp,sp,-12
   c0690:	dfc00215 	stw	ra,8(sp)
   c0694:	df000115 	stw	fp,4(sp)
   c0698:	df000104 	addi	fp,sp,4
    muted = !muted;
   c069c:	d0a0c017 	ldw	r2,-32000(gp)
   c06a0:	1005003a 	cmpeq	r2,r2,zero
   c06a4:	10803fcc 	andi	r2,r2,255
   c06a8:	d0a0c015 	stw	r2,-32000(gp)

    // Update DAC mute bit in digital path control register
    int reg_data = muted ? 0x08 : 0x00;  // Bit 3 is DAC mute
   c06ac:	d0a0c017 	ldw	r2,-32000(gp)
   c06b0:	10000226 	beq	r2,zero,c06bc <toggle_mute+0x30>
   c06b4:	00800204 	movi	r2,8
   c06b8:	00000106 	br	c06c0 <toggle_mute+0x34>
   c06bc:	0005883a 	mov	r2,zero
   c06c0:	e0bfff15 	stw	r2,-4(fp)
    alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_DIGITAL_AUDIO_PATH_CTRL, reg_data);
   c06c4:	d0a0b917 	ldw	r2,-32028(gp)
   c06c8:	e0ffff17 	ldw	r3,-4(fp)
   c06cc:	180d883a 	mov	r6,r3
   c06d0:	01400144 	movi	r5,5
   c06d4:	1009883a 	mov	r4,r2
   c06d8:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
}
   c06dc:	0001883a 	nop
   c06e0:	e037883a 	mov	sp,fp
   c06e4:	dfc00117 	ldw	ra,4(sp)
   c06e8:	df000017 	ldw	fp,0(sp)
   c06ec:	dec00204 	addi	sp,sp,8
   c06f0:	f800283a 	ret

000c06f4 <initialize_audio>:

// Initialize audio codec via I2C - EXACTLY matching the working implementation
int initialize_audio(void) {
   c06f4:	defffc04 	addi	sp,sp,-16
   c06f8:	dfc00315 	stw	ra,12(sp)
   c06fc:	df000215 	stw	fp,8(sp)
   c0700:	df000204 	addi	fp,sp,8
    // Open audio device
    audio_dev = alt_up_audio_open_dev(AUDIO_NAME);
   c0704:	01000334 	movhi	r4,12
   c0708:	21100304 	addi	r4,r4,16396
   c070c:	00c201c0 	call	c201c <alt_up_audio_open_dev>
   c0710:	d0a0b815 	stw	r2,-32032(gp)
    if (audio_dev == NULL) {
   c0714:	d0a0b817 	ldw	r2,-32032(gp)
   c0718:	1000051e 	bne	r2,zero,c0730 <initialize_audio+0x3c>
        printf("Error: could not open audio device\n");
   c071c:	01000334 	movhi	r4,12
   c0720:	21100604 	addi	r4,r4,16408
   c0724:	00c0f3c0 	call	c0f3c <puts>
        return -1;
   c0728:	00bfffc4 	movi	r2,-1
   c072c:	00009506 	br	c0984 <initialize_audio+0x290>
    }

    // Open audio config device
    av_config = alt_up_av_config_open_dev(AUDIO_CONFIG_NAME);
   c0730:	01000334 	movhi	r4,12
   c0734:	21100f04 	addi	r4,r4,16444
   c0738:	00c27ac0 	call	c27ac <alt_up_av_config_open_dev>
   c073c:	d0a0b915 	stw	r2,-32028(gp)
    if (av_config == NULL) {
   c0740:	d0a0b917 	ldw	r2,-32028(gp)
   c0744:	1000051e 	bne	r2,zero,c075c <initialize_audio+0x68>
        printf("Error: could not open audio config device\n");
   c0748:	01000334 	movhi	r4,12
   c074c:	21101404 	addi	r4,r4,16464
   c0750:	00c0f3c0 	call	c0f3c <puts>
        return -1;
   c0754:	00bfffc4 	movi	r2,-1
   c0758:	00008a06 	br	c0984 <initialize_audio+0x290>
    }

    // Wait for audio config to complete
    int timeout = 10000;  // Prevent infinite loop
   c075c:	0089c404 	movi	r2,10000
   c0760:	e0bfff15 	stw	r2,-4(fp)
    while (!alt_up_av_config_read_ready(av_config)) {
   c0764:	00000c06 	br	c0798 <initialize_audio+0xa4>
        if (--timeout <= 0) {
   c0768:	e0bfff17 	ldw	r2,-4(fp)
   c076c:	10bfffc4 	addi	r2,r2,-1
   c0770:	e0bfff15 	stw	r2,-4(fp)
   c0774:	e0bfff17 	ldw	r2,-4(fp)
   c0778:	00800516 	blt	zero,r2,c0790 <initialize_audio+0x9c>
            printf("Error: Audio config device not ready\n");
   c077c:	01000334 	movhi	r4,12
   c0780:	21101f04 	addi	r4,r4,16508
   c0784:	00c0f3c0 	call	c0f3c <puts>
            return -1;
   c0788:	00bfffc4 	movi	r2,-1
   c078c:	00007d06 	br	c0984 <initialize_audio+0x290>
        }
        usleep(1000);
   c0790:	0100fa04 	movi	r4,1000
   c0794:	00c1a980 	call	c1a98 <usleep>
    while (!alt_up_av_config_read_ready(av_config)) {
   c0798:	d0a0b917 	ldw	r2,-32028(gp)
   c079c:	1009883a 	mov	r4,r2
   c07a0:	00c29e80 	call	c29e8 <alt_up_av_config_read_ready>
   c07a4:	103ff026 	beq	r2,zero,c0768 <initialize_audio+0x74>
    }

    // Clear audio FIFOs
    alt_up_audio_reset_audio_core(audio_dev);
   c07a8:	d0a0b817 	ldw	r2,-32032(gp)
   c07ac:	1009883a 	mov	r4,r2
   c07b0:	00c22280 	call	c2228 <alt_up_audio_reset_audio_core>

    // Configure each WM8731 register using the provided HAL functions - EXACTLY AS IN WORKING CODE
    int config_success = 1;
   c07b4:	00800044 	movi	r2,1
   c07b8:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_LEFT_LINE_IN, 0x17) == 0);
   c07bc:	d0a0b917 	ldw	r2,-32028(gp)
   c07c0:	018005c4 	movi	r6,23
   c07c4:	000b883a 	mov	r5,zero
   c07c8:	1009883a 	mov	r4,r2
   c07cc:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c07d0:	1005003a 	cmpeq	r2,r2,zero
   c07d4:	10803fcc 	andi	r2,r2,255
   c07d8:	e0fffe17 	ldw	r3,-8(fp)
   c07dc:	1884703a 	and	r2,r3,r2
   c07e0:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_RIGHT_LINE_IN, 0x17) == 0);
   c07e4:	d0a0b917 	ldw	r2,-32028(gp)
   c07e8:	018005c4 	movi	r6,23
   c07ec:	01400044 	movi	r5,1
   c07f0:	1009883a 	mov	r4,r2
   c07f4:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c07f8:	1005003a 	cmpeq	r2,r2,zero
   c07fc:	10803fcc 	andi	r2,r2,255
   c0800:	e0fffe17 	ldw	r3,-8(fp)
   c0804:	1884703a 	and	r2,r3,r2
   c0808:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_LEFT_HEADPHONE_OUT, 0x79) == 0);
   c080c:	d0a0b917 	ldw	r2,-32028(gp)
   c0810:	01801e44 	movi	r6,121
   c0814:	01400084 	movi	r5,2
   c0818:	1009883a 	mov	r4,r2
   c081c:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0820:	1005003a 	cmpeq	r2,r2,zero
   c0824:	10803fcc 	andi	r2,r2,255
   c0828:	e0fffe17 	ldw	r3,-8(fp)
   c082c:	1884703a 	and	r2,r3,r2
   c0830:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_RIGHT_HEADPHONE_OUT, 0x79) == 0);
   c0834:	d0a0b917 	ldw	r2,-32028(gp)
   c0838:	01801e44 	movi	r6,121
   c083c:	014000c4 	movi	r5,3
   c0840:	1009883a 	mov	r4,r2
   c0844:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0848:	1005003a 	cmpeq	r2,r2,zero
   c084c:	10803fcc 	andi	r2,r2,255
   c0850:	e0fffe17 	ldw	r3,-8(fp)
   c0854:	1884703a 	and	r2,r3,r2
   c0858:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_ANALOG_AUDIO_PATH_CTRL, 0x10) == 0);
   c085c:	d0a0b917 	ldw	r2,-32028(gp)
   c0860:	01800404 	movi	r6,16
   c0864:	01400104 	movi	r5,4
   c0868:	1009883a 	mov	r4,r2
   c086c:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0870:	1005003a 	cmpeq	r2,r2,zero
   c0874:	10803fcc 	andi	r2,r2,255
   c0878:	e0fffe17 	ldw	r3,-8(fp)
   c087c:	1884703a 	and	r2,r3,r2
   c0880:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_DIGITAL_AUDIO_PATH_CTRL, 0x00) == 0);
   c0884:	d0a0b917 	ldw	r2,-32028(gp)
   c0888:	000d883a 	mov	r6,zero
   c088c:	01400144 	movi	r5,5
   c0890:	1009883a 	mov	r4,r2
   c0894:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0898:	1005003a 	cmpeq	r2,r2,zero
   c089c:	10803fcc 	andi	r2,r2,255
   c08a0:	e0fffe17 	ldw	r3,-8(fp)
   c08a4:	1884703a 	and	r2,r3,r2
   c08a8:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_POWER_DOWN_CTRL, 0x00) == 0);
   c08ac:	d0a0b917 	ldw	r2,-32028(gp)
   c08b0:	000d883a 	mov	r6,zero
   c08b4:	01400184 	movi	r5,6
   c08b8:	1009883a 	mov	r4,r2
   c08bc:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c08c0:	1005003a 	cmpeq	r2,r2,zero
   c08c4:	10803fcc 	andi	r2,r2,255
   c08c8:	e0fffe17 	ldw	r3,-8(fp)
   c08cc:	1884703a 	and	r2,r3,r2
   c08d0:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_AUDIO_DIGITAL_INTERFACE, 0x42) == 0);
   c08d4:	d0a0b917 	ldw	r2,-32028(gp)
   c08d8:	01801084 	movi	r6,66
   c08dc:	014001c4 	movi	r5,7
   c08e0:	1009883a 	mov	r4,r2
   c08e4:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c08e8:	1005003a 	cmpeq	r2,r2,zero
   c08ec:	10803fcc 	andi	r2,r2,255
   c08f0:	e0fffe17 	ldw	r3,-8(fp)
   c08f4:	1884703a 	and	r2,r3,r2
   c08f8:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_SAMPLING_CTRL, 0x00) == 0);
   c08fc:	d0a0b917 	ldw	r2,-32028(gp)
   c0900:	000d883a 	mov	r6,zero
   c0904:	01400204 	movi	r5,8
   c0908:	1009883a 	mov	r4,r2
   c090c:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0910:	1005003a 	cmpeq	r2,r2,zero
   c0914:	10803fcc 	andi	r2,r2,255
   c0918:	e0fffe17 	ldw	r3,-8(fp)
   c091c:	1884703a 	and	r2,r3,r2
   c0920:	e0bffe15 	stw	r2,-8(fp)
    config_success &= (alt_up_av_config_write_audio_cfg_register(av_config, AUDIO_REG_ACTIVE_CTRL, 0x01) == 0);
   c0924:	d0a0b917 	ldw	r2,-32028(gp)
   c0928:	01800044 	movi	r6,1
   c092c:	01400244 	movi	r5,9
   c0930:	1009883a 	mov	r4,r2
   c0934:	00c2a200 	call	c2a20 <alt_up_av_config_write_audio_cfg_register>
   c0938:	1005003a 	cmpeq	r2,r2,zero
   c093c:	10803fcc 	andi	r2,r2,255
   c0940:	e0fffe17 	ldw	r3,-8(fp)
   c0944:	1884703a 	and	r2,r3,r2
   c0948:	e0bffe15 	stw	r2,-8(fp)

    if (!config_success) {
   c094c:	e0bffe17 	ldw	r2,-8(fp)
   c0950:	1000051e 	bne	r2,zero,c0968 <initialize_audio+0x274>
        printf("Error: Failed to configure audio codec\n");
   c0954:	01000334 	movhi	r4,12
   c0958:	21102904 	addi	r4,r4,16548
   c095c:	00c0f3c0 	call	c0f3c <puts>
        return -1;
   c0960:	00bfffc4 	movi	r2,-1
   c0964:	00000706 	br	c0984 <initialize_audio+0x290>
    }

    // Enable audio write interrupt
    alt_up_audio_enable_write_interrupt(audio_dev);
   c0968:	d0a0b817 	ldw	r2,-32032(gp)
   c096c:	1009883a 	mov	r4,r2
   c0970:	00c21040 	call	c2104 <alt_up_audio_enable_write_interrupt>

    headphone_volume = DEFAULT_HEADPHONE_VOLUME;
   c0974:	00801e44 	movi	r2,121
   c0978:	d0a00015 	stw	r2,-32768(gp)
    muted = 0;
   c097c:	d020c015 	stw	zero,-32000(gp)

    return 0;
   c0980:	0005883a 	mov	r2,zero
}
   c0984:	e037883a 	mov	sp,fp
   c0988:	dfc00117 	ldw	ra,4(sp)
   c098c:	df000017 	ldw	fp,0(sp)
   c0990:	dec00204 	addi	sp,sp,8
   c0994:	f800283a 	ret

000c0998 <process_audio_buffer>:

// Process and fill audio buffer - copied exactly from working version
void process_audio_buffer(void) {
   c0998:	deff7604 	addi	sp,sp,-552
   c099c:	dfc08915 	stw	ra,548(sp)
   c09a0:	df008815 	stw	fp,544(sp)
   c09a4:	df008804 	addi	fp,sp,544
    // Only process if we're playing audio
    if (!audio_playing) return;
   c09a8:	d0a0ba17 	ldw	r2,-32024(gp)
   c09ac:	10006f26 	beq	r2,zero,c0b6c <process_audio_buffer+0x1d4>

    // Check available space in output FIFO
    unsigned int space_left = alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_LEFT);
   c09b0:	d0a0b817 	ldw	r2,-32032(gp)
   c09b4:	000b883a 	mov	r5,zero
   c09b8:	1009883a 	mov	r4,r2
   c09bc:	00c23ec0 	call	c23ec <alt_up_audio_write_fifo_space>
   c09c0:	e0bffe15 	stw	r2,-8(fp)
    unsigned int space_right = alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_RIGHT);
   c09c4:	d0a0b817 	ldw	r2,-32032(gp)
   c09c8:	01400044 	movi	r5,1
   c09cc:	1009883a 	mov	r4,r2
   c09d0:	00c23ec0 	call	c23ec <alt_up_audio_write_fifo_space>
   c09d4:	e0bffd15 	stw	r2,-12(fp)
    unsigned int space = (space_left < space_right) ? space_left : space_right;
   c09d8:	e0fffe17 	ldw	r3,-8(fp)
   c09dc:	e0bffd17 	ldw	r2,-12(fp)
   c09e0:	1880012e 	bgeu	r3,r2,c09e8 <process_audio_buffer+0x50>
   c09e4:	1805883a 	mov	r2,r3
   c09e8:	e0bffc15 	stw	r2,-16(fp)

    // Don't process if not enough space
    if (space < BUFFER_SIZE) return;
   c09ec:	e0bffc17 	ldw	r2,-16(fp)
   c09f0:	10801028 	cmpgeui	r2,r2,64
   c09f4:	10005f26 	beq	r2,zero,c0b74 <process_audio_buffer+0x1dc>
    // Buffers for audio data
    unsigned int left_buffer[BUFFER_SIZE];
    unsigned int right_buffer[BUFFER_SIZE];

    // Process only if we haven't reached the end of audio data
    if (audio_position < AUDIO_DATA_SIZE || audio_loop) {
   c09f8:	d0e0bb17 	ldw	r3,-32020(gp)
   c09fc:	008000b4 	movhi	r2,2
   c0a00:	10b54f84 	addi	r2,r2,-10946
   c0a04:	10c0020e 	bge	r2,r3,c0a10 <process_audio_buffer+0x78>
   c0a08:	d0a0bc17 	ldw	r2,-32016(gp)
   c0a0c:	10005a26 	beq	r2,zero,c0b78 <process_audio_buffer+0x1e0>
        // Read audio data from ROM
        int16_t* audio_data = (int16_t*)AUDIO_ROM_BASE;
   c0a10:	e03ffb15 	stw	zero,-20(fp)

        for (int i = 0; i < BUFFER_SIZE; i++) {
   c0a14:	e03fff15 	stw	zero,-4(fp)
   c0a18:	00003506 	br	c0af0 <process_audio_buffer+0x158>
            if (audio_position >= AUDIO_DATA_SIZE) {
   c0a1c:	d0e0bb17 	ldw	r3,-32020(gp)
   c0a20:	008000b4 	movhi	r2,2
   c0a24:	10b54f84 	addi	r2,r2,-10946
   c0a28:	10c00e0e 	bge	r2,r3,c0a64 <process_audio_buffer+0xcc>
                if (audio_loop) {
   c0a2c:	d0a0bc17 	ldw	r2,-32016(gp)
   c0a30:	10000526 	beq	r2,zero,c0a48 <process_audio_buffer+0xb0>
                    // Loop back to beginning
                    printf("Looping audio playback\n");
   c0a34:	01000334 	movhi	r4,12
   c0a38:	21103304 	addi	r4,r4,16588
   c0a3c:	00c0f3c0 	call	c0f3c <puts>
                    audio_position = 0;
   c0a40:	d020bb15 	stw	zero,-32020(gp)
   c0a44:	00000706 	br	c0a64 <process_audio_buffer+0xcc>
                } else {
                    // Stop playback at end
                    audio_playing = 0;
   c0a48:	d020ba15 	stw	zero,-32024(gp)
                    update_leds(LED_PAUSED);
   c0a4c:	01000204 	movi	r4,8
   c0a50:	00c0c2c0 	call	c0c2c <update_leds>
                    printf("End of audio reached\n");
   c0a54:	01000334 	movhi	r4,12
   c0a58:	21103904 	addi	r4,r4,16612
   c0a5c:	00c0f3c0 	call	c0f3c <puts>
                    return;
   c0a60:	00004506 	br	c0b78 <process_audio_buffer+0x1e0>
                }
            }

            // Bounds check
            if (audio_position < 0 || audio_position >= AUDIO_DATA_SIZE) {
   c0a64:	d0a0bb17 	ldw	r2,-32020(gp)
   c0a68:	10000416 	blt	r2,zero,c0a7c <process_audio_buffer+0xe4>
   c0a6c:	d0e0bb17 	ldw	r3,-32020(gp)
   c0a70:	008000b4 	movhi	r2,2
   c0a74:	10b54f84 	addi	r2,r2,-10946
   c0a78:	10c0060e 	bge	r2,r3,c0a94 <process_audio_buffer+0xfc>
                printf("Error: Audio position out of bounds: %d\n", audio_position);
   c0a7c:	d0a0bb17 	ldw	r2,-32020(gp)
   c0a80:	100b883a 	mov	r5,r2
   c0a84:	01000334 	movhi	r4,12
   c0a88:	21103f04 	addi	r4,r4,16636
   c0a8c:	00c0e740 	call	c0e74 <printf>
                audio_position = 0;
   c0a90:	d020bb15 	stw	zero,-32020(gp)
            }

            // Read audio sample from ROM (memory-mapped)
            int16_t sample = audio_data[audio_position];
   c0a94:	d0a0bb17 	ldw	r2,-32020(gp)
   c0a98:	1085883a 	add	r2,r2,r2
   c0a9c:	1007883a 	mov	r3,r2
   c0aa0:	e0bffb17 	ldw	r2,-20(fp)
   c0aa4:	10c5883a 	add	r2,r2,r3
   c0aa8:	1080000b 	ldhu	r2,0(r2)
   c0aac:	e0bff88d 	sth	r2,-30(fp)

            // Convert to unsigned int for audio FIFO
            // Same sample for both left and right channels (mono output)
            left_buffer[i] = (unsigned int)sample;
   c0ab0:	e0fff88f 	ldh	r3,-30(fp)
   c0ab4:	e0bfff17 	ldw	r2,-4(fp)
   c0ab8:	100490ba 	slli	r2,r2,2
   c0abc:	e085883a 	add	r2,fp,r2
   c0ac0:	10ffb815 	stw	r3,-288(r2)
            right_buffer[i] = (unsigned int)sample;
   c0ac4:	e0fff88f 	ldh	r3,-30(fp)
   c0ac8:	e0bfff17 	ldw	r2,-4(fp)
   c0acc:	100490ba 	slli	r2,r2,2
   c0ad0:	e085883a 	add	r2,fp,r2
   c0ad4:	10ff7815 	stw	r3,-544(r2)

            audio_position++;
   c0ad8:	d0a0bb17 	ldw	r2,-32020(gp)
   c0adc:	10800044 	addi	r2,r2,1
   c0ae0:	d0a0bb15 	stw	r2,-32020(gp)
        for (int i = 0; i < BUFFER_SIZE; i++) {
   c0ae4:	e0bfff17 	ldw	r2,-4(fp)
   c0ae8:	10800044 	addi	r2,r2,1
   c0aec:	e0bfff15 	stw	r2,-4(fp)
   c0af0:	e0bfff17 	ldw	r2,-4(fp)
   c0af4:	10801010 	cmplti	r2,r2,64
   c0af8:	103fc81e 	bne	r2,zero,c0a1c <process_audio_buffer+0x84>
        }

        // Write audio data to codec
        int written_left = alt_up_audio_write_fifo(audio_dev, left_buffer, BUFFER_SIZE, ALT_UP_AUDIO_LEFT);
   c0afc:	d0a0b817 	ldw	r2,-32032(gp)
   c0b00:	e0ffb804 	addi	r3,fp,-288
   c0b04:	000f883a 	mov	r7,zero
   c0b08:	01801004 	movi	r6,64
   c0b0c:	180b883a 	mov	r5,r3
   c0b10:	1009883a 	mov	r4,r2
   c0b14:	00c25fc0 	call	c25fc <alt_up_audio_write_fifo>
   c0b18:	e0bffa15 	stw	r2,-24(fp)
        int written_right = alt_up_audio_write_fifo(audio_dev, right_buffer, BUFFER_SIZE, ALT_UP_AUDIO_RIGHT);
   c0b1c:	d0a0b817 	ldw	r2,-32032(gp)
   c0b20:	e0ff7804 	addi	r3,fp,-544
   c0b24:	01c00044 	movi	r7,1
   c0b28:	01801004 	movi	r6,64
   c0b2c:	180b883a 	mov	r5,r3
   c0b30:	1009883a 	mov	r4,r2
   c0b34:	00c25fc0 	call	c25fc <alt_up_audio_write_fifo>
   c0b38:	e0bff915 	stw	r2,-28(fp)

        // Check if write was successful
        if (written_left != BUFFER_SIZE || written_right != BUFFER_SIZE) {
   c0b3c:	e0bffa17 	ldw	r2,-24(fp)
   c0b40:	10801018 	cmpnei	r2,r2,64
   c0b44:	1000031e 	bne	r2,zero,c0b54 <process_audio_buffer+0x1bc>
   c0b48:	e0bff917 	ldw	r2,-28(fp)
   c0b4c:	10801020 	cmpeqi	r2,r2,64
   c0b50:	1000091e 	bne	r2,zero,c0b78 <process_audio_buffer+0x1e0>
            printf("Warning: Not all audio samples written (%d, %d)\n", written_left, written_right);
   c0b54:	e1bff917 	ldw	r6,-28(fp)
   c0b58:	e17ffa17 	ldw	r5,-24(fp)
   c0b5c:	01000334 	movhi	r4,12
   c0b60:	21104a04 	addi	r4,r4,16680
   c0b64:	00c0e740 	call	c0e74 <printf>
   c0b68:	00000306 	br	c0b78 <process_audio_buffer+0x1e0>
    if (!audio_playing) return;
   c0b6c:	0001883a 	nop
   c0b70:	00000106 	br	c0b78 <process_audio_buffer+0x1e0>
    if (space < BUFFER_SIZE) return;
   c0b74:	0001883a 	nop
        }
    }
}
   c0b78:	e037883a 	mov	sp,fp
   c0b7c:	dfc00117 	ldw	ra,4(sp)
   c0b80:	df000017 	ldw	fp,0(sp)
   c0b84:	dec00204 	addi	sp,sp,8
   c0b88:	f800283a 	ret

000c0b8c <handle_audio_interrupt>:

// Audio interrupt handler
void handle_audio_interrupt(void* context) {
   c0b8c:	defffc04 	addi	sp,sp,-16
   c0b90:	dfc00315 	stw	ra,12(sp)
   c0b94:	df000215 	stw	fp,8(sp)
   c0b98:	df000204 	addi	fp,sp,8
   c0b9c:	e13ffe15 	stw	r4,-8(fp)
    // Check which type of interrupt occurred
    int write_pending = alt_up_audio_write_interrupt_pending(audio_dev);
   c0ba0:	d0a0b817 	ldw	r2,-32032(gp)
   c0ba4:	1009883a 	mov	r4,r2
   c0ba8:	00c21ec0 	call	c21ec <alt_up_audio_write_interrupt_pending>
   c0bac:	e0bfff15 	stw	r2,-4(fp)

    // If write interrupt (FIFO has space), fill the buffer
    if (write_pending) {
   c0bb0:	e0bfff17 	ldw	r2,-4(fp)
   c0bb4:	10000826 	beq	r2,zero,c0bd8 <handle_audio_interrupt+0x4c>
        // Clear the interrupt by handling it
        alt_up_audio_disable_write_interrupt(audio_dev);
   c0bb8:	d0a0b817 	ldw	r2,-32032(gp)
   c0bbc:	1009883a 	mov	r4,r2
   c0bc0:	00c21580 	call	c2158 <alt_up_audio_disable_write_interrupt>

        // Signal buffer underrun
        buffer_underrun = 1;
   c0bc4:	00800044 	movi	r2,1
   c0bc8:	d0a0bd15 	stw	r2,-32012(gp)

        // Re-enable interrupt after handling
        alt_up_audio_enable_write_interrupt(audio_dev);
   c0bcc:	d0a0b817 	ldw	r2,-32032(gp)
   c0bd0:	1009883a 	mov	r4,r2
   c0bd4:	00c21040 	call	c2104 <alt_up_audio_enable_write_interrupt>
    }
}
   c0bd8:	0001883a 	nop
   c0bdc:	e037883a 	mov	sp,fp
   c0be0:	dfc00117 	ldw	ra,4(sp)
   c0be4:	df000017 	ldw	fp,0(sp)
   c0be8:	dec00204 	addi	sp,sp,8
   c0bec:	f800283a 	ret

000c0bf0 <timer_isr>:

// Timer ISR - called periodically to ensure audio buffer is filled
alt_u32 timer_isr(void* context) {
   c0bf0:	defffd04 	addi	sp,sp,-12
   c0bf4:	dfc00215 	stw	ra,8(sp)
   c0bf8:	df000115 	stw	fp,4(sp)
   c0bfc:	df000104 	addi	fp,sp,4
   c0c00:	e13fff15 	stw	r4,-4(fp)
    process_audio_buffer();
   c0c04:	00c09980 	call	c0998 <process_audio_buffer>
   c0c08:	d0a0c517 	ldw	r2,-31980(gp)

    // Return time until next timer interrupt (continue with same period)
    return alt_ticks_per_second()/10;
   c0c0c:	01400284 	movi	r5,10
   c0c10:	1009883a 	mov	r4,r2
   c0c14:	00c0d500 	call	c0d50 <__udivsi3>
}
   c0c18:	e037883a 	mov	sp,fp
   c0c1c:	dfc00117 	ldw	ra,4(sp)
   c0c20:	df000017 	ldw	fp,0(sp)
   c0c24:	dec00204 	addi	sp,sp,8
   c0c28:	f800283a 	ret

000c0c2c <update_leds>:

// Update LED status
void update_leds(int status) {
   c0c2c:	defffe04 	addi	sp,sp,-8
   c0c30:	df000115 	stw	fp,4(sp)
   c0c34:	df000104 	addi	fp,sp,4
   c0c38:	e13fff15 	stw	r4,-4(fp)
    IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, status);
   c0c3c:	e0ffff17 	ldw	r3,-4(fp)
   c0c40:	00800434 	movhi	r2,16
   c0c44:	10c41035 	stwio	r3,4160(r2)
}
   c0c48:	0001883a 	nop
   c0c4c:	e037883a 	mov	sp,fp
   c0c50:	df000017 	ldw	fp,0(sp)
   c0c54:	dec00104 	addi	sp,sp,4
   c0c58:	f800283a 	ret

000c0c5c <__divsi3>:
   c0c5c:	20001a16 	blt	r4,zero,c0cc8 <__divsi3+0x6c>
   c0c60:	000f883a 	mov	r7,zero
   c0c64:	2800020e 	bge	r5,zero,c0c70 <__divsi3+0x14>
   c0c68:	014bc83a 	sub	r5,zero,r5
   c0c6c:	39c0005c 	xori	r7,r7,1
   c0c70:	200d883a 	mov	r6,r4
   c0c74:	00c00044 	movi	r3,1
   c0c78:	2900092e 	bgeu	r5,r4,c0ca0 <__divsi3+0x44>
   c0c7c:	00800804 	movi	r2,32
   c0c80:	00c00044 	movi	r3,1
   c0c84:	00000106 	br	c0c8c <__divsi3+0x30>
   c0c88:	10001226 	beq	r2,zero,c0cd4 <__divsi3+0x78>
   c0c8c:	294b883a 	add	r5,r5,r5
   c0c90:	10bfffc4 	addi	r2,r2,-1
   c0c94:	18c7883a 	add	r3,r3,r3
   c0c98:	293ffb36 	bltu	r5,r4,c0c88 <__divsi3+0x2c>
   c0c9c:	18000d26 	beq	r3,zero,c0cd4 <__divsi3+0x78>
   c0ca0:	0005883a 	mov	r2,zero
   c0ca4:	31400236 	bltu	r6,r5,c0cb0 <__divsi3+0x54>
   c0ca8:	314dc83a 	sub	r6,r6,r5
   c0cac:	10c4b03a 	or	r2,r2,r3
   c0cb0:	1806d07a 	srli	r3,r3,1
   c0cb4:	280ad07a 	srli	r5,r5,1
   c0cb8:	183ffa1e 	bne	r3,zero,c0ca4 <__divsi3+0x48>
   c0cbc:	38000126 	beq	r7,zero,c0cc4 <__divsi3+0x68>
   c0cc0:	0085c83a 	sub	r2,zero,r2
   c0cc4:	f800283a 	ret
   c0cc8:	0109c83a 	sub	r4,zero,r4
   c0ccc:	01c00044 	movi	r7,1
   c0cd0:	003fe406 	br	c0c64 <__divsi3+0x8>
   c0cd4:	0005883a 	mov	r2,zero
   c0cd8:	003ff806 	br	c0cbc <__divsi3+0x60>

000c0cdc <__modsi3>:
   c0cdc:	20001716 	blt	r4,zero,c0d3c <__modsi3+0x60>
   c0ce0:	000f883a 	mov	r7,zero
   c0ce4:	2005883a 	mov	r2,r4
   c0ce8:	2800010e 	bge	r5,zero,c0cf0 <__modsi3+0x14>
   c0cec:	014bc83a 	sub	r5,zero,r5
   c0cf0:	00c00044 	movi	r3,1
   c0cf4:	2900092e 	bgeu	r5,r4,c0d1c <__modsi3+0x40>
   c0cf8:	01800804 	movi	r6,32
   c0cfc:	00c00044 	movi	r3,1
   c0d00:	00000106 	br	c0d08 <__modsi3+0x2c>
   c0d04:	30001026 	beq	r6,zero,c0d48 <__modsi3+0x6c>
   c0d08:	294b883a 	add	r5,r5,r5
   c0d0c:	31bfffc4 	addi	r6,r6,-1
   c0d10:	18c7883a 	add	r3,r3,r3
   c0d14:	293ffb36 	bltu	r5,r4,c0d04 <__modsi3+0x28>
   c0d18:	18000b26 	beq	r3,zero,c0d48 <__modsi3+0x6c>
   c0d1c:	1806d07a 	srli	r3,r3,1
   c0d20:	11400136 	bltu	r2,r5,c0d28 <__modsi3+0x4c>
   c0d24:	1145c83a 	sub	r2,r2,r5
   c0d28:	280ad07a 	srli	r5,r5,1
   c0d2c:	183ffb1e 	bne	r3,zero,c0d1c <__modsi3+0x40>
   c0d30:	38000126 	beq	r7,zero,c0d38 <__modsi3+0x5c>
   c0d34:	0085c83a 	sub	r2,zero,r2
   c0d38:	f800283a 	ret
   c0d3c:	0109c83a 	sub	r4,zero,r4
   c0d40:	01c00044 	movi	r7,1
   c0d44:	003fe706 	br	c0ce4 <__modsi3+0x8>
   c0d48:	2005883a 	mov	r2,r4
   c0d4c:	003ff806 	br	c0d30 <__modsi3+0x54>

000c0d50 <__udivsi3>:
   c0d50:	200d883a 	mov	r6,r4
   c0d54:	2900152e 	bgeu	r5,r4,c0dac <__udivsi3+0x5c>
   c0d58:	28001416 	blt	r5,zero,c0dac <__udivsi3+0x5c>
   c0d5c:	00800804 	movi	r2,32
   c0d60:	00c00044 	movi	r3,1
   c0d64:	00000206 	br	c0d70 <__udivsi3+0x20>
   c0d68:	10000e26 	beq	r2,zero,c0da4 <__udivsi3+0x54>
   c0d6c:	28000416 	blt	r5,zero,c0d80 <__udivsi3+0x30>
   c0d70:	294b883a 	add	r5,r5,r5
   c0d74:	10bfffc4 	addi	r2,r2,-1
   c0d78:	18c7883a 	add	r3,r3,r3
   c0d7c:	293ffa36 	bltu	r5,r4,c0d68 <__udivsi3+0x18>
   c0d80:	18000826 	beq	r3,zero,c0da4 <__udivsi3+0x54>
   c0d84:	0005883a 	mov	r2,zero
   c0d88:	31400236 	bltu	r6,r5,c0d94 <__udivsi3+0x44>
   c0d8c:	314dc83a 	sub	r6,r6,r5
   c0d90:	10c4b03a 	or	r2,r2,r3
   c0d94:	1806d07a 	srli	r3,r3,1
   c0d98:	280ad07a 	srli	r5,r5,1
   c0d9c:	183ffa1e 	bne	r3,zero,c0d88 <__udivsi3+0x38>
   c0da0:	f800283a 	ret
   c0da4:	0005883a 	mov	r2,zero
   c0da8:	f800283a 	ret
   c0dac:	00c00044 	movi	r3,1
   c0db0:	003ff406 	br	c0d84 <__udivsi3+0x34>

000c0db4 <__umodsi3>:
   c0db4:	2005883a 	mov	r2,r4
   c0db8:	2900132e 	bgeu	r5,r4,c0e08 <__umodsi3+0x54>
   c0dbc:	28001216 	blt	r5,zero,c0e08 <__umodsi3+0x54>
   c0dc0:	01800804 	movi	r6,32
   c0dc4:	00c00044 	movi	r3,1
   c0dc8:	00000206 	br	c0dd4 <__umodsi3+0x20>
   c0dcc:	30000c26 	beq	r6,zero,c0e00 <__umodsi3+0x4c>
   c0dd0:	28000416 	blt	r5,zero,c0de4 <__umodsi3+0x30>
   c0dd4:	294b883a 	add	r5,r5,r5
   c0dd8:	31bfffc4 	addi	r6,r6,-1
   c0ddc:	18c7883a 	add	r3,r3,r3
   c0de0:	293ffa36 	bltu	r5,r4,c0dcc <__umodsi3+0x18>
   c0de4:	18000626 	beq	r3,zero,c0e00 <__umodsi3+0x4c>
   c0de8:	1806d07a 	srli	r3,r3,1
   c0dec:	11400136 	bltu	r2,r5,c0df4 <__umodsi3+0x40>
   c0df0:	1145c83a 	sub	r2,r2,r5
   c0df4:	280ad07a 	srli	r5,r5,1
   c0df8:	183ffb1e 	bne	r3,zero,c0de8 <__umodsi3+0x34>
   c0dfc:	f800283a 	ret
   c0e00:	2005883a 	mov	r2,r4
   c0e04:	f800283a 	ret
   c0e08:	00c00044 	movi	r3,1
   c0e0c:	003ff606 	br	c0de8 <__umodsi3+0x34>

000c0e10 <__mulsi3>:
   c0e10:	0005883a 	mov	r2,zero
   c0e14:	20000726 	beq	r4,zero,c0e34 <__mulsi3+0x24>
   c0e18:	20c0004c 	andi	r3,r4,1
   c0e1c:	2008d07a 	srli	r4,r4,1
   c0e20:	18000126 	beq	r3,zero,c0e28 <__mulsi3+0x18>
   c0e24:	1145883a 	add	r2,r2,r5
   c0e28:	294b883a 	add	r5,r5,r5
   c0e2c:	203ffa1e 	bne	r4,zero,c0e18 <__mulsi3+0x8>
   c0e30:	f800283a 	ret
   c0e34:	f800283a 	ret

000c0e38 <_printf_r>:
   c0e38:	defffd04 	addi	sp,sp,-12
   c0e3c:	dfc00015 	stw	ra,0(sp)
   c0e40:	d9800115 	stw	r6,4(sp)
   c0e44:	d9c00215 	stw	r7,8(sp)
   c0e48:	21800217 	ldw	r6,8(r4)
   c0e4c:	00c00334 	movhi	r3,12
   c0e50:	18c54204 	addi	r3,r3,5384
   c0e54:	30c00115 	stw	r3,4(r6)
   c0e58:	280d883a 	mov	r6,r5
   c0e5c:	21400217 	ldw	r5,8(r4)
   c0e60:	d9c00104 	addi	r7,sp,4
   c0e64:	00c0fd40 	call	c0fd4 <___vfprintf_internal_r>
   c0e68:	dfc00017 	ldw	ra,0(sp)
   c0e6c:	dec00304 	addi	sp,sp,12
   c0e70:	f800283a 	ret

000c0e74 <printf>:
   c0e74:	defffc04 	addi	sp,sp,-16
   c0e78:	dfc00015 	stw	ra,0(sp)
   c0e7c:	d9400115 	stw	r5,4(sp)
   c0e80:	d9800215 	stw	r6,8(sp)
   c0e84:	d9c00315 	stw	r7,12(sp)
   c0e88:	00800334 	movhi	r2,12
   c0e8c:	10d11017 	ldw	r3,17472(r2)
   c0e90:	00800334 	movhi	r2,12
   c0e94:	10854204 	addi	r2,r2,5384
   c0e98:	19400217 	ldw	r5,8(r3)
   c0e9c:	d9800104 	addi	r6,sp,4
   c0ea0:	28800115 	stw	r2,4(r5)
   c0ea4:	200b883a 	mov	r5,r4
   c0ea8:	19000217 	ldw	r4,8(r3)
   c0eac:	00c14f00 	call	c14f0 <__vfprintf_internal>
   c0eb0:	dfc00017 	ldw	ra,0(sp)
   c0eb4:	dec00404 	addi	sp,sp,16
   c0eb8:	f800283a 	ret

000c0ebc <_puts_r>:
   c0ebc:	defffd04 	addi	sp,sp,-12
   c0ec0:	dc000015 	stw	r16,0(sp)
   c0ec4:	2021883a 	mov	r16,r4
   c0ec8:	2809883a 	mov	r4,r5
   c0ecc:	dfc00215 	stw	ra,8(sp)
   c0ed0:	dc400115 	stw	r17,4(sp)
   c0ed4:	2823883a 	mov	r17,r5
   c0ed8:	00c0f4c0 	call	c0f4c <strlen>
   c0edc:	81400217 	ldw	r5,8(r16)
   c0ee0:	00c00334 	movhi	r3,12
   c0ee4:	18c54204 	addi	r3,r3,5384
   c0ee8:	28c00115 	stw	r3,4(r5)
   c0eec:	100f883a 	mov	r7,r2
   c0ef0:	880d883a 	mov	r6,r17
   c0ef4:	8009883a 	mov	r4,r16
   c0ef8:	00c15080 	call	c1508 <__sfvwrite_small_dev>
   c0efc:	10ffffe0 	cmpeqi	r3,r2,-1
   c0f00:	1800091e 	bne	r3,zero,c0f28 <_puts_r+0x6c>
   c0f04:	81400217 	ldw	r5,8(r16)
   c0f08:	01800334 	movhi	r6,12
   c0f0c:	01c00044 	movi	r7,1
   c0f10:	28800117 	ldw	r2,4(r5)
   c0f14:	31905704 	addi	r6,r6,16732
   c0f18:	8009883a 	mov	r4,r16
   c0f1c:	103ee83a 	callr	r2
   c0f20:	10bfffe0 	cmpeqi	r2,r2,-1
   c0f24:	0085c83a 	sub	r2,zero,r2
   c0f28:	dfc00217 	ldw	ra,8(sp)
   c0f2c:	dc400117 	ldw	r17,4(sp)
   c0f30:	dc000017 	ldw	r16,0(sp)
   c0f34:	dec00304 	addi	sp,sp,12
   c0f38:	f800283a 	ret

000c0f3c <puts>:
   c0f3c:	00800334 	movhi	r2,12
   c0f40:	200b883a 	mov	r5,r4
   c0f44:	11111017 	ldw	r4,17472(r2)
   c0f48:	00c0ebc1 	jmpi	c0ebc <_puts_r>

000c0f4c <strlen>:
   c0f4c:	2005883a 	mov	r2,r4
   c0f50:	10c00007 	ldb	r3,0(r2)
   c0f54:	1800021e 	bne	r3,zero,c0f60 <strlen+0x14>
   c0f58:	1105c83a 	sub	r2,r2,r4
   c0f5c:	f800283a 	ret
   c0f60:	10800044 	addi	r2,r2,1
   c0f64:	003ffa06 	br	c0f50 <strlen+0x4>

000c0f68 <print_repeat>:
   c0f68:	defffb04 	addi	sp,sp,-20
   c0f6c:	dc800315 	stw	r18,12(sp)
   c0f70:	dc400215 	stw	r17,8(sp)
   c0f74:	dc000115 	stw	r16,4(sp)
   c0f78:	dfc00415 	stw	ra,16(sp)
   c0f7c:	2025883a 	mov	r18,r4
   c0f80:	2823883a 	mov	r17,r5
   c0f84:	d9800005 	stb	r6,0(sp)
   c0f88:	3821883a 	mov	r16,r7
   c0f8c:	04000716 	blt	zero,r16,c0fac <print_repeat+0x44>
   c0f90:	0005883a 	mov	r2,zero
   c0f94:	dfc00417 	ldw	ra,16(sp)
   c0f98:	dc800317 	ldw	r18,12(sp)
   c0f9c:	dc400217 	ldw	r17,8(sp)
   c0fa0:	dc000117 	ldw	r16,4(sp)
   c0fa4:	dec00504 	addi	sp,sp,20
   c0fa8:	f800283a 	ret
   c0fac:	88800117 	ldw	r2,4(r17)
   c0fb0:	01c00044 	movi	r7,1
   c0fb4:	d80d883a 	mov	r6,sp
   c0fb8:	880b883a 	mov	r5,r17
   c0fbc:	9009883a 	mov	r4,r18
   c0fc0:	103ee83a 	callr	r2
   c0fc4:	843fffc4 	addi	r16,r16,-1
   c0fc8:	103ff026 	beq	r2,zero,c0f8c <print_repeat+0x24>
   c0fcc:	00bfffc4 	movi	r2,-1
   c0fd0:	003ff006 	br	c0f94 <print_repeat+0x2c>

000c0fd4 <___vfprintf_internal_r>:
   c0fd4:	deffe604 	addi	sp,sp,-104
   c0fd8:	ddc01715 	stw	r23,92(sp)
   c0fdc:	dd801615 	stw	r22,88(sp)
   c0fe0:	dd401515 	stw	r21,84(sp)
   c0fe4:	dd001415 	stw	r20,80(sp)
   c0fe8:	dcc01315 	stw	r19,76(sp)
   c0fec:	dc801215 	stw	r18,72(sp)
   c0ff0:	dc401115 	stw	r17,68(sp)
   c0ff4:	dc001015 	stw	r16,64(sp)
   c0ff8:	dfc01915 	stw	ra,100(sp)
   c0ffc:	df001815 	stw	fp,96(sp)
   c1000:	2025883a 	mov	r18,r4
   c1004:	2823883a 	mov	r17,r5
   c1008:	d9800515 	stw	r6,20(sp)
   c100c:	382f883a 	mov	r23,r7
   c1010:	0021883a 	mov	r16,zero
   c1014:	d8000215 	stw	zero,8(sp)
   c1018:	d8000015 	stw	zero,0(sp)
   c101c:	0029883a 	mov	r20,zero
   c1020:	002d883a 	mov	r22,zero
   c1024:	0027883a 	mov	r19,zero
   c1028:	002b883a 	mov	r21,zero
   c102c:	d8000115 	stw	zero,4(sp)
   c1030:	0005883a 	mov	r2,zero
   c1034:	00000206 	br	c1040 <___vfprintf_internal_r+0x6c>
   c1038:	114000e0 	cmpeqi	r5,r2,3
   c103c:	28004e1e 	bne	r5,zero,c1178 <___vfprintf_internal_r+0x1a4>
   c1040:	d8c00517 	ldw	r3,20(sp)
   c1044:	19000003 	ldbu	r4,0(r3)
   c1048:	18c00044 	addi	r3,r3,1
   c104c:	d8c00515 	stw	r3,20(sp)
   c1050:	20c03fcc 	andi	r3,r4,255
   c1054:	18c0201c 	xori	r3,r3,128
   c1058:	18ffe004 	addi	r3,r3,-128
   c105c:	18001026 	beq	r3,zero,c10a0 <___vfprintf_internal_r+0xcc>
   c1060:	114000a0 	cmpeqi	r5,r2,2
   c1064:	28001f1e 	bne	r5,zero,c10e4 <___vfprintf_internal_r+0x110>
   c1068:	114000c8 	cmpgei	r5,r2,3
   c106c:	283ff21e 	bne	r5,zero,c1038 <___vfprintf_internal_r+0x64>
   c1070:	1000181e 	bne	r2,zero,c10d4 <___vfprintf_internal_r+0x100>
   c1074:	18c00960 	cmpeqi	r3,r3,37
   c1078:	18010e1e 	bne	r3,zero,c14b4 <___vfprintf_internal_r+0x4e0>
   c107c:	88800117 	ldw	r2,4(r17)
   c1080:	d9000805 	stb	r4,32(sp)
   c1084:	01c00044 	movi	r7,1
   c1088:	d9800804 	addi	r6,sp,32
   c108c:	880b883a 	mov	r5,r17
   c1090:	9009883a 	mov	r4,r18
   c1094:	103ee83a 	callr	r2
   c1098:	10001e26 	beq	r2,zero,c1114 <___vfprintf_internal_r+0x140>
   c109c:	043fffc4 	movi	r16,-1
   c10a0:	8005883a 	mov	r2,r16
   c10a4:	dfc01917 	ldw	ra,100(sp)
   c10a8:	df001817 	ldw	fp,96(sp)
   c10ac:	ddc01717 	ldw	r23,92(sp)
   c10b0:	dd801617 	ldw	r22,88(sp)
   c10b4:	dd401517 	ldw	r21,84(sp)
   c10b8:	dd001417 	ldw	r20,80(sp)
   c10bc:	dcc01317 	ldw	r19,76(sp)
   c10c0:	dc801217 	ldw	r18,72(sp)
   c10c4:	dc401117 	ldw	r17,68(sp)
   c10c8:	dc001017 	ldw	r16,64(sp)
   c10cc:	dec01a04 	addi	sp,sp,104
   c10d0:	f800283a 	ret
   c10d4:	18800c20 	cmpeqi	r2,r3,48
   c10d8:	1000ff1e 	bne	r2,zero,c14d8 <___vfprintf_internal_r+0x504>
   c10dc:	18800958 	cmpnei	r2,r3,37
   c10e0:	103fe626 	beq	r2,zero,c107c <___vfprintf_internal_r+0xa8>
   c10e4:	213ff404 	addi	r4,r4,-48
   c10e8:	21003fcc 	andi	r4,r4,255
   c10ec:	208002a8 	cmpgeui	r2,r4,10
   c10f0:	10000c1e 	bne	r2,zero,c1124 <___vfprintf_internal_r+0x150>
   c10f4:	98bfffe0 	cmpeqi	r2,r19,-1
   c10f8:	1000081e 	bne	r2,zero,c111c <___vfprintf_internal_r+0x148>
   c10fc:	980490ba 	slli	r2,r19,2
   c1100:	14c5883a 	add	r2,r2,r19
   c1104:	1004907a 	slli	r2,r2,1
   c1108:	20a7883a 	add	r19,r4,r2
   c110c:	00800084 	movi	r2,2
   c1110:	003fcb06 	br	c1040 <___vfprintf_internal_r+0x6c>
   c1114:	84000044 	addi	r16,r16,1
   c1118:	003fc906 	br	c1040 <___vfprintf_internal_r+0x6c>
   c111c:	0005883a 	mov	r2,zero
   c1120:	003ff906 	br	c1108 <___vfprintf_internal_r+0x134>
   c1124:	18800ba0 	cmpeqi	r2,r3,46
   c1128:	1000ef1e 	bne	r2,zero,c14e8 <___vfprintf_internal_r+0x514>
   c112c:	18801b20 	cmpeqi	r2,r3,108
   c1130:	1000ec1e 	bne	r2,zero,c14e4 <___vfprintf_internal_r+0x510>
   c1134:	b0bfffe0 	cmpeqi	r2,r22,-1
   c1138:	10001c1e 	bne	r2,zero,c11ac <___vfprintf_internal_r+0x1d8>
   c113c:	d8000115 	stw	zero,4(sp)
   c1140:	18801be0 	cmpeqi	r2,r3,111
   c1144:	1000ba1e 	bne	r2,zero,c1430 <___vfprintf_internal_r+0x45c>
   c1148:	18801c08 	cmpgei	r2,r3,112
   c114c:	1000581e 	bne	r2,zero,c12b0 <___vfprintf_internal_r+0x2dc>
   c1150:	188018e0 	cmpeqi	r2,r3,99
   c1154:	1000bd1e 	bne	r2,zero,c144c <___vfprintf_internal_r+0x478>
   c1158:	18801908 	cmpgei	r2,r3,100
   c115c:	1000151e 	bne	r2,zero,c11b4 <___vfprintf_internal_r+0x1e0>
   c1160:	18c01620 	cmpeqi	r3,r3,88
   c1164:	183fb226 	beq	r3,zero,c1030 <___vfprintf_internal_r+0x5c>
   c1168:	a800721e 	bne	r21,zero,c1334 <___vfprintf_internal_r+0x360>
   c116c:	00800044 	movi	r2,1
   c1170:	d8800215 	stw	r2,8(sp)
   c1174:	00007006 	br	c1338 <___vfprintf_internal_r+0x364>
   c1178:	213ff404 	addi	r4,r4,-48
   c117c:	21003fcc 	andi	r4,r4,255
   c1180:	214002a8 	cmpgeui	r5,r4,10
   c1184:	283fe91e 	bne	r5,zero,c112c <___vfprintf_internal_r+0x158>
   c1188:	b0ffffe0 	cmpeqi	r3,r22,-1
   c118c:	1800051e 	bne	r3,zero,c11a4 <___vfprintf_internal_r+0x1d0>
   c1190:	b00690ba 	slli	r3,r22,2
   c1194:	1d87883a 	add	r3,r3,r22
   c1198:	1806907a 	slli	r3,r3,1
   c119c:	20ed883a 	add	r22,r4,r3
   c11a0:	003fa706 	br	c1040 <___vfprintf_internal_r+0x6c>
   c11a4:	0007883a 	mov	r3,zero
   c11a8:	003ffc06 	br	c119c <___vfprintf_internal_r+0x1c8>
   c11ac:	05800044 	movi	r22,1
   c11b0:	003fe306 	br	c1140 <___vfprintf_internal_r+0x16c>
   c11b4:	18801920 	cmpeqi	r2,r3,100
   c11b8:	1000021e 	bne	r2,zero,c11c4 <___vfprintf_internal_r+0x1f0>
   c11bc:	18c01a60 	cmpeqi	r3,r3,105
   c11c0:	183f9b26 	beq	r3,zero,c1030 <___vfprintf_internal_r+0x5c>
   c11c4:	b8800104 	addi	r2,r23,4
   c11c8:	d8800415 	stw	r2,16(sp)
   c11cc:	d8800017 	ldw	r2,0(sp)
   c11d0:	10009826 	beq	r2,zero,c1434 <___vfprintf_internal_r+0x460>
   c11d4:	bdc00017 	ldw	r23,0(r23)
   c11d8:	b8009a0e 	bge	r23,zero,c1444 <___vfprintf_internal_r+0x470>
   c11dc:	05efc83a 	sub	r23,zero,r23
   c11e0:	02400044 	movi	r9,1
   c11e4:	df000804 	addi	fp,sp,32
   c11e8:	e00d883a 	mov	r6,fp
   c11ec:	b800541e 	bne	r23,zero,c1340 <___vfprintf_internal_r+0x36c>
   c11f0:	e185c83a 	sub	r2,fp,r6
   c11f4:	d8800315 	stw	r2,12(sp)
   c11f8:	b085c83a 	sub	r2,r22,r2
   c11fc:	00800b0e 	bge	zero,r2,c122c <___vfprintf_internal_r+0x258>
   c1200:	d8c01004 	addi	r3,sp,64
   c1204:	e0c0072e 	bgeu	fp,r3,c1224 <___vfprintf_internal_r+0x250>
   c1208:	e085883a 	add	r2,fp,r2
   c120c:	01000c04 	movi	r4,48
   c1210:	e7000044 	addi	fp,fp,1
   c1214:	e13fffc5 	stb	r4,-1(fp)
   c1218:	17000226 	beq	r2,fp,c1224 <___vfprintf_internal_r+0x250>
   c121c:	d8c01004 	addi	r3,sp,64
   c1220:	e0fffb36 	bltu	fp,r3,c1210 <___vfprintf_internal_r+0x23c>
   c1224:	e185c83a 	sub	r2,fp,r6
   c1228:	d8800315 	stw	r2,12(sp)
   c122c:	d8800317 	ldw	r2,12(sp)
   c1230:	4891883a 	add	r8,r9,r2
   c1234:	d8800117 	ldw	r2,4(sp)
   c1238:	9a2fc83a 	sub	r23,r19,r8
   c123c:	10005926 	beq	r2,zero,c13a4 <___vfprintf_internal_r+0x3d0>
   c1240:	48000a26 	beq	r9,zero,c126c <___vfprintf_internal_r+0x298>
   c1244:	00800b44 	movi	r2,45
   c1248:	d88007c5 	stb	r2,31(sp)
   c124c:	88800117 	ldw	r2,4(r17)
   c1250:	01c00044 	movi	r7,1
   c1254:	d98007c4 	addi	r6,sp,31
   c1258:	880b883a 	mov	r5,r17
   c125c:	9009883a 	mov	r4,r18
   c1260:	103ee83a 	callr	r2
   c1264:	103f8d1e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c1268:	84000044 	addi	r16,r16,1
   c126c:	05c0070e 	bge	zero,r23,c128c <___vfprintf_internal_r+0x2b8>
   c1270:	b80f883a 	mov	r7,r23
   c1274:	01800c04 	movi	r6,48
   c1278:	880b883a 	mov	r5,r17
   c127c:	9009883a 	mov	r4,r18
   c1280:	00c0f680 	call	c0f68 <print_repeat>
   c1284:	103f851e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c1288:	85e1883a 	add	r16,r16,r23
   c128c:	d8800317 	ldw	r2,12(sp)
   c1290:	e011883a 	mov	r8,fp
   c1294:	172fc83a 	sub	r23,r2,fp
   c1298:	ba05883a 	add	r2,r23,r8
   c129c:	00805716 	blt	zero,r2,c13fc <___vfprintf_internal_r+0x428>
   c12a0:	8707883a 	add	r3,r16,fp
   c12a4:	ddc00417 	ldw	r23,16(sp)
   c12a8:	1a21c83a 	sub	r16,r3,r8
   c12ac:	003f6006 	br	c1030 <___vfprintf_internal_r+0x5c>
   c12b0:	18801d60 	cmpeqi	r2,r3,117
   c12b4:	10005f1e 	bne	r2,zero,c1434 <___vfprintf_internal_r+0x460>
   c12b8:	18801e20 	cmpeqi	r2,r3,120
   c12bc:	10001e1e 	bne	r2,zero,c1338 <___vfprintf_internal_r+0x364>
   c12c0:	18c01ce0 	cmpeqi	r3,r3,115
   c12c4:	183f5a26 	beq	r3,zero,c1030 <___vfprintf_internal_r+0x5c>
   c12c8:	b8800104 	addi	r2,r23,4
   c12cc:	d8800315 	stw	r2,12(sp)
   c12d0:	b8800017 	ldw	r2,0(r23)
   c12d4:	1009883a 	mov	r4,r2
   c12d8:	1039883a 	mov	fp,r2
   c12dc:	00c0f4c0 	call	c0f4c <strlen>
   c12e0:	988fc83a 	sub	r7,r19,r2
   c12e4:	102f883a 	mov	r23,r2
   c12e8:	01c0080e 	bge	zero,r7,c130c <___vfprintf_internal_r+0x338>
   c12ec:	01800804 	movi	r6,32
   c12f0:	880b883a 	mov	r5,r17
   c12f4:	9009883a 	mov	r4,r18
   c12f8:	d9c00415 	stw	r7,16(sp)
   c12fc:	00c0f680 	call	c0f68 <print_repeat>
   c1300:	103f661e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c1304:	d9c00417 	ldw	r7,16(sp)
   c1308:	81e1883a 	add	r16,r16,r7
   c130c:	88800117 	ldw	r2,4(r17)
   c1310:	b80f883a 	mov	r7,r23
   c1314:	e00d883a 	mov	r6,fp
   c1318:	880b883a 	mov	r5,r17
   c131c:	9009883a 	mov	r4,r18
   c1320:	103ee83a 	callr	r2
   c1324:	103f5d1e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c1328:	85e1883a 	add	r16,r16,r23
   c132c:	ddc00317 	ldw	r23,12(sp)
   c1330:	003f4306 	br	c1040 <___vfprintf_internal_r+0x6c>
   c1334:	dd400215 	stw	r21,8(sp)
   c1338:	05000404 	movi	r20,16
   c133c:	00003d06 	br	c1434 <___vfprintf_internal_r+0x460>
   c1340:	b809883a 	mov	r4,r23
   c1344:	a00b883a 	mov	r5,r20
   c1348:	da400615 	stw	r9,24(sp)
   c134c:	00c0d500 	call	c0d50 <__udivsi3>
   c1350:	1009883a 	mov	r4,r2
   c1354:	a00b883a 	mov	r5,r20
   c1358:	d8800315 	stw	r2,12(sp)
   c135c:	00c0e100 	call	c0e10 <__mulsi3>
   c1360:	b8afc83a 	sub	r23,r23,r2
   c1364:	b8800288 	cmpgei	r2,r23,10
   c1368:	d9000317 	ldw	r4,12(sp)
   c136c:	da400617 	ldw	r9,24(sp)
   c1370:	d9800804 	addi	r6,sp,32
   c1374:	1000051e 	bne	r2,zero,c138c <___vfprintf_internal_r+0x3b8>
   c1378:	bdc00c04 	addi	r23,r23,48
   c137c:	e7000044 	addi	fp,fp,1
   c1380:	e5ffffc5 	stb	r23,-1(fp)
   c1384:	202f883a 	mov	r23,r4
   c1388:	003f9806 	br	c11ec <___vfprintf_internal_r+0x218>
   c138c:	d8800217 	ldw	r2,8(sp)
   c1390:	10000226 	beq	r2,zero,c139c <___vfprintf_internal_r+0x3c8>
   c1394:	bdc00dc4 	addi	r23,r23,55
   c1398:	003ff806 	br	c137c <___vfprintf_internal_r+0x3a8>
   c139c:	bdc015c4 	addi	r23,r23,87
   c13a0:	003ff606 	br	c137c <___vfprintf_internal_r+0x3a8>
   c13a4:	05c0090e 	bge	zero,r23,c13cc <___vfprintf_internal_r+0x3f8>
   c13a8:	b80f883a 	mov	r7,r23
   c13ac:	01800804 	movi	r6,32
   c13b0:	880b883a 	mov	r5,r17
   c13b4:	9009883a 	mov	r4,r18
   c13b8:	da400615 	stw	r9,24(sp)
   c13bc:	00c0f680 	call	c0f68 <print_repeat>
   c13c0:	103f361e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c13c4:	da400617 	ldw	r9,24(sp)
   c13c8:	85e1883a 	add	r16,r16,r23
   c13cc:	483faf26 	beq	r9,zero,c128c <___vfprintf_internal_r+0x2b8>
   c13d0:	00800b44 	movi	r2,45
   c13d4:	d88007c5 	stb	r2,31(sp)
   c13d8:	88800117 	ldw	r2,4(r17)
   c13dc:	01c00044 	movi	r7,1
   c13e0:	d98007c4 	addi	r6,sp,31
   c13e4:	880b883a 	mov	r5,r17
   c13e8:	9009883a 	mov	r4,r18
   c13ec:	103ee83a 	callr	r2
   c13f0:	103f2a1e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c13f4:	84000044 	addi	r16,r16,1
   c13f8:	003fa406 	br	c128c <___vfprintf_internal_r+0x2b8>
   c13fc:	40bfffc3 	ldbu	r2,-1(r8)
   c1400:	01c00044 	movi	r7,1
   c1404:	423fffc4 	addi	r8,r8,-1
   c1408:	d88007c5 	stb	r2,31(sp)
   c140c:	88800117 	ldw	r2,4(r17)
   c1410:	d98007c4 	addi	r6,sp,31
   c1414:	880b883a 	mov	r5,r17
   c1418:	9009883a 	mov	r4,r18
   c141c:	da000315 	stw	r8,12(sp)
   c1420:	103ee83a 	callr	r2
   c1424:	da000317 	ldw	r8,12(sp)
   c1428:	103f9b26 	beq	r2,zero,c1298 <___vfprintf_internal_r+0x2c4>
   c142c:	003f1b06 	br	c109c <___vfprintf_internal_r+0xc8>
   c1430:	05000204 	movi	r20,8
   c1434:	b8800104 	addi	r2,r23,4
   c1438:	d8800415 	stw	r2,16(sp)
   c143c:	bdc00017 	ldw	r23,0(r23)
   c1440:	d8000015 	stw	zero,0(sp)
   c1444:	0013883a 	mov	r9,zero
   c1448:	003f6606 	br	c11e4 <___vfprintf_internal_r+0x210>
   c144c:	98800090 	cmplti	r2,r19,2
   c1450:	1000091e 	bne	r2,zero,c1478 <___vfprintf_internal_r+0x4a4>
   c1454:	99ffffc4 	addi	r7,r19,-1
   c1458:	01800804 	movi	r6,32
   c145c:	880b883a 	mov	r5,r17
   c1460:	9009883a 	mov	r4,r18
   c1464:	d9c00315 	stw	r7,12(sp)
   c1468:	00c0f680 	call	c0f68 <print_repeat>
   c146c:	103f0b1e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c1470:	d9c00317 	ldw	r7,12(sp)
   c1474:	81e1883a 	add	r16,r16,r7
   c1478:	b8800017 	ldw	r2,0(r23)
   c147c:	b8c00104 	addi	r3,r23,4
   c1480:	01c00044 	movi	r7,1
   c1484:	d8800805 	stb	r2,32(sp)
   c1488:	88800117 	ldw	r2,4(r17)
   c148c:	d9800804 	addi	r6,sp,32
   c1490:	880b883a 	mov	r5,r17
   c1494:	9009883a 	mov	r4,r18
   c1498:	d8c00315 	stw	r3,12(sp)
   c149c:	103ee83a 	callr	r2
   c14a0:	103efe1e 	bne	r2,zero,c109c <___vfprintf_internal_r+0xc8>
   c14a4:	d8c00317 	ldw	r3,12(sp)
   c14a8:	84000044 	addi	r16,r16,1
   c14ac:	182f883a 	mov	r23,r3
   c14b0:	003ee306 	br	c1040 <___vfprintf_internal_r+0x6c>
   c14b4:	00800044 	movi	r2,1
   c14b8:	d8000215 	stw	zero,8(sp)
   c14bc:	002b883a 	mov	r21,zero
   c14c0:	d8000115 	stw	zero,4(sp)
   c14c4:	d8800015 	stw	r2,0(sp)
   c14c8:	05000284 	movi	r20,10
   c14cc:	05bfffc4 	movi	r22,-1
   c14d0:	04ffffc4 	movi	r19,-1
   c14d4:	003eda06 	br	c1040 <___vfprintf_internal_r+0x6c>
   c14d8:	00800044 	movi	r2,1
   c14dc:	d8800115 	stw	r2,4(sp)
   c14e0:	003f0a06 	br	c110c <___vfprintf_internal_r+0x138>
   c14e4:	05400044 	movi	r21,1
   c14e8:	008000c4 	movi	r2,3
   c14ec:	003ed406 	br	c1040 <___vfprintf_internal_r+0x6c>

000c14f0 <__vfprintf_internal>:
   c14f0:	00800334 	movhi	r2,12
   c14f4:	300f883a 	mov	r7,r6
   c14f8:	280d883a 	mov	r6,r5
   c14fc:	200b883a 	mov	r5,r4
   c1500:	11111017 	ldw	r4,17472(r2)
   c1504:	00c0fd41 	jmpi	c0fd4 <___vfprintf_internal_r>

000c1508 <__sfvwrite_small_dev>:
   c1508:	2880000b 	ldhu	r2,0(r5)
   c150c:	1080020c 	andi	r2,r2,8
   c1510:	10002526 	beq	r2,zero,c15a8 <__sfvwrite_small_dev+0xa0>
   c1514:	2880008f 	ldh	r2,2(r5)
   c1518:	defffb04 	addi	sp,sp,-20
   c151c:	dcc00315 	stw	r19,12(sp)
   c1520:	dc800215 	stw	r18,8(sp)
   c1524:	dc400115 	stw	r17,4(sp)
   c1528:	dc000015 	stw	r16,0(sp)
   c152c:	dfc00415 	stw	ra,16(sp)
   c1530:	2027883a 	mov	r19,r4
   c1534:	2821883a 	mov	r16,r5
   c1538:	3025883a 	mov	r18,r6
   c153c:	3823883a 	mov	r17,r7
   c1540:	1000100e 	bge	r2,zero,c1584 <__sfvwrite_small_dev+0x7c>
   c1544:	8080000b 	ldhu	r2,0(r16)
   c1548:	10801014 	ori	r2,r2,64
   c154c:	8080000d 	sth	r2,0(r16)
   c1550:	00bfffc4 	movi	r2,-1
   c1554:	00000d06 	br	c158c <__sfvwrite_small_dev+0x84>
   c1558:	88810050 	cmplti	r2,r17,1025
   c155c:	880f883a 	mov	r7,r17
   c1560:	1000011e 	bne	r2,zero,c1568 <__sfvwrite_small_dev+0x60>
   c1564:	01c10004 	movi	r7,1024
   c1568:	8140008f 	ldh	r5,2(r16)
   c156c:	900d883a 	mov	r6,r18
   c1570:	9809883a 	mov	r4,r19
   c1574:	00c15b00 	call	c15b0 <_write_r>
   c1578:	00bff20e 	bge	zero,r2,c1544 <__sfvwrite_small_dev+0x3c>
   c157c:	88a3c83a 	sub	r17,r17,r2
   c1580:	90a5883a 	add	r18,r18,r2
   c1584:	047ff416 	blt	zero,r17,c1558 <__sfvwrite_small_dev+0x50>
   c1588:	0005883a 	mov	r2,zero
   c158c:	dfc00417 	ldw	ra,16(sp)
   c1590:	dcc00317 	ldw	r19,12(sp)
   c1594:	dc800217 	ldw	r18,8(sp)
   c1598:	dc400117 	ldw	r17,4(sp)
   c159c:	dc000017 	ldw	r16,0(sp)
   c15a0:	dec00504 	addi	sp,sp,20
   c15a4:	f800283a 	ret
   c15a8:	00bfffc4 	movi	r2,-1
   c15ac:	f800283a 	ret

000c15b0 <_write_r>:
   c15b0:	defffe04 	addi	sp,sp,-8
   c15b4:	dc000015 	stw	r16,0(sp)
   c15b8:	00800334 	movhi	r2,12
   c15bc:	2021883a 	mov	r16,r4
   c15c0:	2809883a 	mov	r4,r5
   c15c4:	300b883a 	mov	r5,r6
   c15c8:	380d883a 	mov	r6,r7
   c15cc:	dfc00115 	stw	ra,4(sp)
   c15d0:	1011d015 	stw	zero,18240(r2)
   c15d4:	00c1b040 	call	c1b04 <write>
   c15d8:	10ffffd8 	cmpnei	r3,r2,-1
   c15dc:	1800041e 	bne	r3,zero,c15f0 <_write_r+0x40>
   c15e0:	00c00334 	movhi	r3,12
   c15e4:	18d1d017 	ldw	r3,18240(r3)
   c15e8:	18000126 	beq	r3,zero,c15f0 <_write_r+0x40>
   c15ec:	80c00015 	stw	r3,0(r16)
   c15f0:	dfc00117 	ldw	ra,4(sp)
   c15f4:	dc000017 	ldw	r16,0(sp)
   c15f8:	dec00204 	addi	sp,sp,8
   c15fc:	f800283a 	ret

000c1600 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   c1600:	defff404 	addi	sp,sp,-48
   c1604:	df000b15 	stw	fp,44(sp)
   c1608:	df000b04 	addi	fp,sp,44
   c160c:	e13ff815 	stw	r4,-32(fp)
   c1610:	e17ff715 	stw	r5,-36(fp)
   c1614:	e1bff615 	stw	r6,-40(fp)
   c1618:	e1fff515 	stw	r7,-44(fp)
  alt_irq_context irq_context;
  alt_u64 current_nticks = 0;
   c161c:	e03ffe15 	stw	zero,-8(fp)
   c1620:	e03fff15 	stw	zero,-4(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   c1624:	d0a0c517 	ldw	r2,-31980(gp)
  
  if (alt_ticks_per_second ())
   c1628:	10004826 	beq	r2,zero,c174c <alt_alarm_start+0x14c>
  {
    if (alarm)
   c162c:	e0bff817 	ldw	r2,-32(fp)
   c1630:	10004426 	beq	r2,zero,c1744 <alt_alarm_start+0x144>
    {
      alarm->callback = callback;
   c1634:	e0bff817 	ldw	r2,-32(fp)
   c1638:	e0fff617 	ldw	r3,-40(fp)
   c163c:	10c00415 	stw	r3,16(r2)
      alarm->context  = context;
   c1640:	e0bff817 	ldw	r2,-32(fp)
   c1644:	e0fff517 	ldw	r3,-44(fp)
   c1648:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
   c164c:	0005303a 	rdctl	r2,status
   c1650:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c1654:	e0fff917 	ldw	r3,-28(fp)
   c1658:	00bfff84 	movi	r2,-2
   c165c:	1884703a 	and	r2,r3,r2
   c1660:	1001703a 	wrctl	status,r2
  return context;
   c1664:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
   c1668:	e0bffd15 	stw	r2,-12(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u64 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   c166c:	d0a0c617 	ldw	r2,-31976(gp)
   c1670:	d0e0c717 	ldw	r3,-31972(gp)
      
      current_nticks = alt_nticks();
   c1674:	e0bffe15 	stw	r2,-8(fp)
   c1678:	e0ffff15 	stw	r3,-4(fp)
      
      alarm->time = (alt_u64)nticks + current_nticks + 1; 
   c167c:	e0bff717 	ldw	r2,-36(fp)
   c1680:	1011883a 	mov	r8,r2
   c1684:	0013883a 	mov	r9,zero
   c1688:	e13ffe17 	ldw	r4,-8(fp)
   c168c:	e17fff17 	ldw	r5,-4(fp)
   c1690:	4105883a 	add	r2,r8,r4
   c1694:	120d803a 	cmpltu	r6,r2,r8
   c1698:	4947883a 	add	r3,r9,r5
   c169c:	30c9883a 	add	r4,r6,r3
   c16a0:	2007883a 	mov	r3,r4
   c16a4:	1009883a 	mov	r4,r2
   c16a8:	180b883a 	mov	r5,r3
   c16ac:	01800044 	movi	r6,1
   c16b0:	000f883a 	mov	r7,zero
   c16b4:	2185883a 	add	r2,r4,r6
   c16b8:	1111803a 	cmpltu	r8,r2,r4
   c16bc:	29c7883a 	add	r3,r5,r7
   c16c0:	40c9883a 	add	r4,r8,r3
   c16c4:	2007883a 	mov	r3,r4
   c16c8:	1009883a 	mov	r4,r2
   c16cc:	180b883a 	mov	r5,r3
   c16d0:	e0bff817 	ldw	r2,-32(fp)
   c16d4:	11000215 	stw	r4,8(r2)
   c16d8:	11400315 	stw	r5,12(r2)
          
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   c16dc:	e0bff817 	ldw	r2,-32(fp)
   c16e0:	d0e00204 	addi	r3,gp,-32760
   c16e4:	e0fffb15 	stw	r3,-20(fp)
   c16e8:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   c16ec:	e0bffa17 	ldw	r2,-24(fp)
   c16f0:	e0fffb17 	ldw	r3,-20(fp)
   c16f4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   c16f8:	e0bffb17 	ldw	r2,-20(fp)
   c16fc:	10c00017 	ldw	r3,0(r2)
   c1700:	e0bffa17 	ldw	r2,-24(fp)
   c1704:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   c1708:	e0bffb17 	ldw	r2,-20(fp)
   c170c:	10800017 	ldw	r2,0(r2)
   c1710:	e0fffa17 	ldw	r3,-24(fp)
   c1714:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   c1718:	e0bffb17 	ldw	r2,-20(fp)
   c171c:	e0fffa17 	ldw	r3,-24(fp)
   c1720:	10c00015 	stw	r3,0(r2)
}
   c1724:	0001883a 	nop
   c1728:	e0bffd17 	ldw	r2,-12(fp)
   c172c:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
   c1730:	e0bffc17 	ldw	r2,-16(fp)
   c1734:	1001703a 	wrctl	status,r2
}
   c1738:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
   c173c:	0005883a 	mov	r2,zero
   c1740:	00000306 	br	c1750 <alt_alarm_start+0x150>
    }
    else
    {
      return -EINVAL;
   c1744:	00bffa84 	movi	r2,-22
   c1748:	00000106 	br	c1750 <alt_alarm_start+0x150>
    }
  }
  else
  {
    return -ENOTSUP;
   c174c:	00bfde84 	movi	r2,-134
  }
}
   c1750:	e037883a 	mov	sp,fp
   c1754:	df000017 	ldw	fp,0(sp)
   c1758:	dec00104 	addi	sp,sp,4
   c175c:	f800283a 	ret

000c1760 <alt_load_section>:
 */  

void alt_load (void)
{
  /* 
   * Copy the .rwdata section. 
   c1760:	defffc04 	addi	sp,sp,-16
   c1764:	df000315 	stw	fp,12(sp)
   c1768:	df000304 	addi	fp,sp,12
   c176c:	e13fff15 	stw	r4,-4(fp)
   c1770:	e17ffe15 	stw	r5,-8(fp)
   c1774:	e1bffd15 	stw	r6,-12(fp)
   */
   c1778:	e0fffe17 	ldw	r3,-8(fp)
   c177c:	e0bfff17 	ldw	r2,-4(fp)
   c1780:	18800c26 	beq	r3,r2,c17b4 <alt_load_section+0x54>

  alt_load_section (&__flash_rwdata_start, 
   c1784:	00000806 	br	c17a8 <alt_load_section+0x48>
		               &__ram_rwdata_start,
		               &__ram_rwdata_end);
   c1788:	e0ffff17 	ldw	r3,-4(fp)
   c178c:	18800104 	addi	r2,r3,4
   c1790:	e0bfff15 	stw	r2,-4(fp)
   c1794:	e0bffe17 	ldw	r2,-8(fp)
   c1798:	11000104 	addi	r4,r2,4
   c179c:	e13ffe15 	stw	r4,-8(fp)
   c17a0:	18c00017 	ldw	r3,0(r3)
   c17a4:	10c00015 	stw	r3,0(r2)
  alt_load_section (&__flash_rwdata_start, 
   c17a8:	e0fffe17 	ldw	r3,-8(fp)
   c17ac:	e0bffd17 	ldw	r2,-12(fp)
   c17b0:	18bff51e 	bne	r3,r2,c1788 <alt_load_section+0x28>

  /*
   * Copy the exception handler.
   c17b4:	0001883a 	nop
   c17b8:	e037883a 	mov	sp,fp
   c17bc:	df000017 	ldw	fp,0(sp)
   c17c0:	dec00104 	addi	sp,sp,4
   c17c4:	f800283a 	ret

000c17c8 <alt_load>:
{
   c17c8:	defffe04 	addi	sp,sp,-8
   c17cc:	dfc00115 	stw	ra,4(sp)
   c17d0:	df000015 	stw	fp,0(sp)
   c17d4:	d839883a 	mov	fp,sp
  alt_load_section (&__flash_rwdata_start, 
   c17d8:	01800334 	movhi	r6,12
   c17dc:	31911a04 	addi	r6,r6,17512
   c17e0:	01400334 	movhi	r5,12
   c17e4:	29506d04 	addi	r5,r5,16820
   c17e8:	01000334 	movhi	r4,12
   c17ec:	21111a04 	addi	r4,r4,17512
   c17f0:	00c17600 	call	c1760 <alt_load_section>
   */

  alt_load_section (&__flash_exceptions_start, 
   c17f4:	01800334 	movhi	r6,12
   c17f8:	31808a04 	addi	r6,r6,552
   c17fc:	01400334 	movhi	r5,12
   c1800:	29400804 	addi	r5,r5,32
   c1804:	01000334 	movhi	r4,12
   c1808:	21000804 	addi	r4,r4,32
   c180c:	00c17600 	call	c1760 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   c1810:	01800334 	movhi	r6,12
   c1814:	31906d04 	addi	r6,r6,16820
   c1818:	01400334 	movhi	r5,12
   c181c:	294fb004 	addi	r5,r5,16064
   c1820:	01000334 	movhi	r4,12
   c1824:	210fb004 	addi	r4,r4,16064
   c1828:	00c17600 	call	c1760 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   c182c:	00c31140 	call	c3114 <alt_dcache_flush_all>
  alt_icache_flush_all();
   c1830:	00c339c0 	call	c339c <alt_icache_flush_all>
}
   c1834:	0001883a 	nop
   c1838:	e037883a 	mov	sp,fp
   c183c:	dfc00117 	ldw	ra,4(sp)
   c1840:	df000017 	ldw	fp,0(sp)
   c1844:	dec00204 	addi	sp,sp,8
   c1848:	f800283a 	ret

000c184c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   c184c:	defffd04 	addi	sp,sp,-12
   c1850:	dfc00215 	stw	ra,8(sp)
   c1854:	df000115 	stw	fp,4(sp)
   c1858:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   c185c:	0009883a 	mov	r4,zero
   c1860:	00c1c3c0 	call	c1c3c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   c1864:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   c1868:	00c1c780 	call	c1c78 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   c186c:	01800334 	movhi	r6,12
   c1870:	31905804 	addi	r6,r6,16736
   c1874:	01400334 	movhi	r5,12
   c1878:	29505804 	addi	r5,r5,16736
   c187c:	01000334 	movhi	r4,12
   c1880:	21105804 	addi	r4,r4,16736
   c1884:	00c34900 	call	c3490 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   c1888:	00c32440 	call	c3244 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   c188c:	01000334 	movhi	r4,12
   c1890:	210caa04 	addi	r4,r4,12968
   c1894:	00c3bcc0 	call	c3bcc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   c1898:	d0a0c217 	ldw	r2,-31992(gp)
   c189c:	d0e0c317 	ldw	r3,-31988(gp)
   c18a0:	d120c417 	ldw	r4,-31984(gp)
   c18a4:	200d883a 	mov	r6,r4
   c18a8:	180b883a 	mov	r5,r3
   c18ac:	1009883a 	mov	r4,r2
   c18b0:	00c02640 	call	c0264 <main>
   c18b4:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   c18b8:	01000044 	movi	r4,1
   c18bc:	00c30380 	call	c3038 <close>
  exit (result);
   c18c0:	e13fff17 	ldw	r4,-4(fp)
   c18c4:	00c3be00 	call	c3be0 <exit>

000c18c8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   c18c8:	defffa04 	addi	sp,sp,-24
   c18cc:	df000515 	stw	fp,20(sp)
   c18d0:	df000504 	addi	fp,sp,20
   c18d4:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
   c18d8:	0005303a 	rdctl	r2,status
   c18dc:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c18e0:	e0fffc17 	ldw	r3,-16(fp)
   c18e4:	00bfff84 	movi	r2,-2
   c18e8:	1884703a 	and	r2,r3,r2
   c18ec:	1001703a 	wrctl	status,r2
  return context;
   c18f0:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   c18f4:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
   c18f8:	e0bffb17 	ldw	r2,-20(fp)
   c18fc:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   c1900:	e0bffd17 	ldw	r2,-12(fp)
   c1904:	10800017 	ldw	r2,0(r2)
   c1908:	e0fffd17 	ldw	r3,-12(fp)
   c190c:	18c00117 	ldw	r3,4(r3)
   c1910:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   c1914:	e0bffd17 	ldw	r2,-12(fp)
   c1918:	10800117 	ldw	r2,4(r2)
   c191c:	e0fffd17 	ldw	r3,-12(fp)
   c1920:	18c00017 	ldw	r3,0(r3)
   c1924:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   c1928:	e0bffd17 	ldw	r2,-12(fp)
   c192c:	e0fffd17 	ldw	r3,-12(fp)
   c1930:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   c1934:	e0bffd17 	ldw	r2,-12(fp)
   c1938:	e0fffd17 	ldw	r3,-12(fp)
   c193c:	10c00015 	stw	r3,0(r2)
} 
   c1940:	0001883a 	nop
   c1944:	e0bfff17 	ldw	r2,-4(fp)
   c1948:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
   c194c:	e0bffe17 	ldw	r2,-8(fp)
   c1950:	1001703a 	wrctl	status,r2
}
   c1954:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
   c1958:	0001883a 	nop
   c195c:	e037883a 	mov	sp,fp
   c1960:	df000017 	ldw	fp,0(sp)
   c1964:	dec00104 	addi	sp,sp,4
   c1968:	f800283a 	ret

000c196c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   c196c:	defff904 	addi	sp,sp,-28
   c1970:	dfc00615 	stw	ra,24(sp)
   c1974:	df000515 	stw	fp,20(sp)
   c1978:	dc400415 	stw	r17,16(sp)
   c197c:	dc000315 	stw	r16,12(sp)
   c1980:	df000504 	addi	fp,sp,20
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   c1984:	d0a00217 	ldw	r2,-32760(gp)
   c1988:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   c198c:	d120c617 	ldw	r4,-31976(gp)
   c1990:	d160c717 	ldw	r5,-31972(gp)
   c1994:	01800044 	movi	r6,1
   c1998:	000f883a 	mov	r7,zero
   c199c:	2185883a 	add	r2,r4,r6
   c19a0:	1111803a 	cmpltu	r8,r2,r4
   c19a4:	29c7883a 	add	r3,r5,r7
   c19a8:	40c9883a 	add	r4,r8,r3
   c19ac:	2007883a 	mov	r3,r4
   c19b0:	1009883a 	mov	r4,r2
   c19b4:	180b883a 	mov	r5,r3
   c19b8:	d120c615 	stw	r4,-31976(gp)
   c19bc:	d160c715 	stw	r5,-31972(gp)
 
  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   c19c0:	00002906 	br	c1a68 <alt_tick+0xfc>
  {
    next = (alt_alarm*) alarm->llist.next;
   c19c4:	e0bffd17 	ldw	r2,-12(fp)
   c19c8:	10800017 	ldw	r2,0(r2)
   c19cc:	e0bffc15 	stw	r2,-16(fp)
    
    /* if the alarm period has expired, make the callback */    
    if (alarm->time <= _alt_nticks)
   c19d0:	e13ffd17 	ldw	r4,-12(fp)
   c19d4:	20800217 	ldw	r2,8(r4)
   c19d8:	20c00317 	ldw	r3,12(r4)
   c19dc:	d120c617 	ldw	r4,-31976(gp)
   c19e0:	d160c717 	ldw	r5,-31972(gp)
   c19e4:	28c01e36 	bltu	r5,r3,c1a60 <alt_tick+0xf4>
   c19e8:	1940011e 	bne	r3,r5,c19f0 <alt_tick+0x84>
   c19ec:	20801c36 	bltu	r4,r2,c1a60 <alt_tick+0xf4>
    {
      next_callback = alarm->callback (alarm->context);
   c19f0:	e0bffd17 	ldw	r2,-12(fp)
   c19f4:	10800417 	ldw	r2,16(r2)
   c19f8:	e0fffd17 	ldw	r3,-12(fp)
   c19fc:	18c00517 	ldw	r3,20(r3)
   c1a00:	1809883a 	mov	r4,r3
   c1a04:	103ee83a 	callr	r2
   c1a08:	e0bffb15 	stw	r2,-20(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   c1a0c:	e0bffb17 	ldw	r2,-20(fp)
   c1a10:	1000031e 	bne	r2,zero,c1a20 <alt_tick+0xb4>
      {
        alt_alarm_stop (alarm);
   c1a14:	e13ffd17 	ldw	r4,-12(fp)
   c1a18:	00c18c80 	call	c18c8 <alt_alarm_stop>
   c1a1c:	00001006 	br	c1a60 <alt_tick+0xf4>
      }
      else
      {
        alarm->time += next_callback;
   c1a20:	e0bffd17 	ldw	r2,-12(fp)
   c1a24:	11000217 	ldw	r4,8(r2)
   c1a28:	11400317 	ldw	r5,12(r2)
   c1a2c:	e0bffb17 	ldw	r2,-20(fp)
   c1a30:	1021883a 	mov	r16,r2
   c1a34:	0023883a 	mov	r17,zero
   c1a38:	2405883a 	add	r2,r4,r16
   c1a3c:	110d803a 	cmpltu	r6,r2,r4
   c1a40:	2c47883a 	add	r3,r5,r17
   c1a44:	30c9883a 	add	r4,r6,r3
   c1a48:	2007883a 	mov	r3,r4
   c1a4c:	1009883a 	mov	r4,r2
   c1a50:	180b883a 	mov	r5,r3
   c1a54:	e0bffd17 	ldw	r2,-12(fp)
   c1a58:	11000215 	stw	r4,8(r2)
   c1a5c:	11400315 	stw	r5,12(r2)
      }
    }
    alarm = next;
   c1a60:	e0bffc17 	ldw	r2,-16(fp)
   c1a64:	e0bffd15 	stw	r2,-12(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
   c1a68:	e0fffd17 	ldw	r3,-12(fp)
   c1a6c:	d0a00204 	addi	r2,gp,-32760
   c1a70:	18bfd41e 	bne	r3,r2,c19c4 <alt_tick+0x58>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   c1a74:	0001883a 	nop
}
   c1a78:	0001883a 	nop
   c1a7c:	e6fffe04 	addi	sp,fp,-8
   c1a80:	dfc00317 	ldw	ra,12(sp)
   c1a84:	df000217 	ldw	fp,8(sp)
   c1a88:	dc400117 	ldw	r17,4(sp)
   c1a8c:	dc000017 	ldw	r16,0(sp)
   c1a90:	dec00404 	addi	sp,sp,16
   c1a94:	f800283a 	ret

000c1a98 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
   c1a98:	defffd04 	addi	sp,sp,-12
   c1a9c:	dfc00215 	stw	ra,8(sp)
   c1aa0:	df000115 	stw	fp,4(sp)
   c1aa4:	df000104 	addi	fp,sp,4
   c1aa8:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
   c1aac:	e13fff17 	ldw	r4,-4(fp)
   c1ab0:	00c2ea40 	call	c2ea4 <alt_busy_sleep>
}
   c1ab4:	e037883a 	mov	sp,fp
   c1ab8:	dfc00117 	ldw	ra,4(sp)
   c1abc:	df000017 	ldw	fp,0(sp)
   c1ac0:	dec00204 	addi	sp,sp,8
   c1ac4:	f800283a 	ret

000c1ac8 <alt_get_errno>:
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
   c1ac8:	defffe04 	addi	sp,sp,-8
   c1acc:	dfc00115 	stw	ra,4(sp)
   c1ad0:	df000015 	stw	fp,0(sp)
   c1ad4:	d839883a 	mov	fp,sp
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
   c1ad8:	d0a00917 	ldw	r2,-32732(gp)
   c1adc:	10000326 	beq	r2,zero,c1aec <alt_get_errno+0x24>
   c1ae0:	d0a00917 	ldw	r2,-32732(gp)
   c1ae4:	103ee83a 	callr	r2
   c1ae8:	00000106 	br	c1af0 <alt_get_errno+0x28>
   c1aec:	d0a0c104 	addi	r2,gp,-31996
#endif /* ALT_STDERR_PRESENT */
   c1af0:	e037883a 	mov	sp,fp
   c1af4:	dfc00117 	ldw	ra,4(sp)
   c1af8:	df000017 	ldw	fp,0(sp)
   c1afc:	dec00204 	addi	sp,sp,8
   c1b00:	f800283a 	ret

000c1b04 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   c1b04:	defff904 	addi	sp,sp,-28
   c1b08:	dfc00615 	stw	ra,24(sp)
   c1b0c:	df000515 	stw	fp,20(sp)
   c1b10:	df000504 	addi	fp,sp,20
   c1b14:	e13ffd15 	stw	r4,-12(fp)
   c1b18:	e17ffc15 	stw	r5,-16(fp)
   c1b1c:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   c1b20:	e0bffd17 	ldw	r2,-12(fp)
   c1b24:	10000916 	blt	r2,zero,c1b4c <write+0x48>
   c1b28:	e0fffd17 	ldw	r3,-12(fp)
   c1b2c:	1805883a 	mov	r2,r3
   c1b30:	1085883a 	add	r2,r2,r2
   c1b34:	10c5883a 	add	r2,r2,r3
   c1b38:	100490ba 	slli	r2,r2,2
   c1b3c:	00c00334 	movhi	r3,12
   c1b40:	18d0af04 	addi	r3,r3,17084
   c1b44:	10c5883a 	add	r2,r2,r3
   c1b48:	00000106 	br	c1b50 <write+0x4c>
   c1b4c:	0005883a 	mov	r2,zero
   c1b50:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
   c1b54:	e0bfff17 	ldw	r2,-4(fp)
   c1b58:	10002126 	beq	r2,zero,c1be0 <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   c1b5c:	e0bfff17 	ldw	r2,-4(fp)
   c1b60:	10800217 	ldw	r2,8(r2)
   c1b64:	108000cc 	andi	r2,r2,3
   c1b68:	10001826 	beq	r2,zero,c1bcc <write+0xc8>
   c1b6c:	e0bfff17 	ldw	r2,-4(fp)
   c1b70:	10800017 	ldw	r2,0(r2)
   c1b74:	10800617 	ldw	r2,24(r2)
   c1b78:	10001426 	beq	r2,zero,c1bcc <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   c1b7c:	e0bfff17 	ldw	r2,-4(fp)
   c1b80:	10800017 	ldw	r2,0(r2)
   c1b84:	10800617 	ldw	r2,24(r2)
   c1b88:	e0fffb17 	ldw	r3,-20(fp)
   c1b8c:	180d883a 	mov	r6,r3
   c1b90:	e17ffc17 	ldw	r5,-16(fp)
   c1b94:	e13fff17 	ldw	r4,-4(fp)
   c1b98:	103ee83a 	callr	r2
   c1b9c:	e0bffe15 	stw	r2,-8(fp)
   c1ba0:	e0bffe17 	ldw	r2,-8(fp)
   c1ba4:	1000070e 	bge	r2,zero,c1bc4 <write+0xc0>
      {
        ALT_ERRNO = -rval;
   c1ba8:	00c1ac80 	call	c1ac8 <alt_get_errno>
   c1bac:	1007883a 	mov	r3,r2
   c1bb0:	e0bffe17 	ldw	r2,-8(fp)
   c1bb4:	0085c83a 	sub	r2,zero,r2
   c1bb8:	18800015 	stw	r2,0(r3)
        return -1;
   c1bbc:	00bfffc4 	movi	r2,-1
   c1bc0:	00000c06 	br	c1bf4 <write+0xf0>
      }
      return rval;
   c1bc4:	e0bffe17 	ldw	r2,-8(fp)
   c1bc8:	00000a06 	br	c1bf4 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
   c1bcc:	00c1ac80 	call	c1ac8 <alt_get_errno>
   c1bd0:	1007883a 	mov	r3,r2
   c1bd4:	00800344 	movi	r2,13
   c1bd8:	18800015 	stw	r2,0(r3)
   c1bdc:	00000406 	br	c1bf0 <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   c1be0:	00c1ac80 	call	c1ac8 <alt_get_errno>
   c1be4:	1007883a 	mov	r3,r2
   c1be8:	00801444 	movi	r2,81
   c1bec:	18800015 	stw	r2,0(r3)
  }
  return -1;
   c1bf0:	00bfffc4 	movi	r2,-1
}
   c1bf4:	e037883a 	mov	sp,fp
   c1bf8:	dfc00117 	ldw	ra,4(sp)
   c1bfc:	df000017 	ldw	fp,0(sp)
   c1c00:	dec00204 	addi	sp,sp,8
   c1c04:	f800283a 	ret

000c1c08 <alt_dev_reg>:
    ALTERA_UP_AVALON_AUDIO_AND_VIDEO_CONFIG_INIT ( AUDIO_CONFIG, audio_config);
    ALTERA_UP_AVALON_AUDIO_INIT ( AUDIO, audio);
}
   c1c08:	defffd04 	addi	sp,sp,-12
   c1c0c:	dfc00215 	stw	ra,8(sp)
   c1c10:	df000115 	stw	fp,4(sp)
   c1c14:	df000104 	addi	fp,sp,4
   c1c18:	e13fff15 	stw	r4,-4(fp)
   c1c1c:	d1600604 	addi	r5,gp,-32744
   c1c20:	e13fff17 	ldw	r4,-4(fp)
   c1c24:	00c319c0 	call	c319c <alt_dev_llist_insert>
   c1c28:	e037883a 	mov	sp,fp
   c1c2c:	dfc00117 	ldw	ra,4(sp)
   c1c30:	df000017 	ldw	fp,0(sp)
   c1c34:	dec00204 	addi	sp,sp,8
   c1c38:	f800283a 	ret

000c1c3c <alt_irq_init>:
{
   c1c3c:	defffd04 	addi	sp,sp,-12
   c1c40:	dfc00215 	stw	ra,8(sp)
   c1c44:	df000115 	stw	fp,4(sp)
   c1c48:	df000104 	addi	fp,sp,4
   c1c4c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
   c1c50:	00c39740 	call	c3974 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   c1c54:	00800044 	movi	r2,1
   c1c58:	1001703a 	wrctl	status,r2
}
   c1c5c:	0001883a 	nop
}
   c1c60:	0001883a 	nop
   c1c64:	e037883a 	mov	sp,fp
   c1c68:	dfc00117 	ldw	ra,4(sp)
   c1c6c:	df000017 	ldw	fp,0(sp)
   c1c70:	dec00204 	addi	sp,sp,8
   c1c74:	f800283a 	ret

000c1c78 <alt_sys_init>:
{
   c1c78:	defffe04 	addi	sp,sp,-8
   c1c7c:	dfc00115 	stw	ra,4(sp)
   c1c80:	df000015 	stw	fp,0(sp)
   c1c84:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
   c1c88:	01c0fa04 	movi	r7,1000
   c1c8c:	01800044 	movi	r6,1
   c1c90:	000b883a 	mov	r5,zero
   c1c94:	01000434 	movhi	r4,16
   c1c98:	21040004 	addi	r4,r4,4096
   c1c9c:	00c1fa00 	call	c1fa0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
   c1ca0:	01000334 	movhi	r4,12
   c1ca4:	21108204 	addi	r4,r4,16904
   c1ca8:	00c1c080 	call	c1c08 <alt_dev_reg>
    ALTERA_UP_AVALON_AUDIO_AND_VIDEO_CONFIG_INIT ( AUDIO_CONFIG, audio_config);
   c1cac:	01000334 	movhi	r4,12
   c1cb0:	21108d04 	addi	r4,r4,16948
   c1cb4:	00c1c080 	call	c1c08 <alt_dev_reg>
    ALTERA_UP_AVALON_AUDIO_INIT ( AUDIO, audio);
   c1cb8:	01000334 	movhi	r4,12
   c1cbc:	21109904 	addi	r4,r4,16996
   c1cc0:	00c1c080 	call	c1c08 <alt_dev_reg>
}
   c1cc4:	0001883a 	nop
   c1cc8:	e037883a 	mov	sp,fp
   c1ccc:	dfc00117 	ldw	ra,4(sp)
   c1cd0:	df000017 	ldw	fp,0(sp)
   c1cd4:	dec00204 	addi	sp,sp,8
   c1cd8:	f800283a 	ret

000c1cdc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   c1cdc:	defffa04 	addi	sp,sp,-24
   c1ce0:	dfc00515 	stw	ra,20(sp)
   c1ce4:	df000415 	stw	fp,16(sp)
   c1ce8:	df000404 	addi	fp,sp,16
   c1cec:	e13ffe15 	stw	r4,-8(fp)
   c1cf0:	e17ffd15 	stw	r5,-12(fp)
   c1cf4:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   c1cf8:	e0bffe17 	ldw	r2,-8(fp)
   c1cfc:	10800017 	ldw	r2,0(r2)
   c1d00:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   c1d04:	e0bfff17 	ldw	r2,-4(fp)
   c1d08:	10c00a04 	addi	r3,r2,40
   c1d0c:	e0bffe17 	ldw	r2,-8(fp)
   c1d10:	10800217 	ldw	r2,8(r2)
   c1d14:	100f883a 	mov	r7,r2
   c1d18:	e1bffc17 	ldw	r6,-16(fp)
   c1d1c:	e17ffd17 	ldw	r5,-12(fp)
   c1d20:	1809883a 	mov	r4,r3
   c1d24:	00c1d9c0 	call	c1d9c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   c1d28:	e037883a 	mov	sp,fp
   c1d2c:	dfc00117 	ldw	ra,4(sp)
   c1d30:	df000017 	ldw	fp,0(sp)
   c1d34:	dec00204 	addi	sp,sp,8
   c1d38:	f800283a 	ret

000c1d3c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   c1d3c:	defffa04 	addi	sp,sp,-24
   c1d40:	dfc00515 	stw	ra,20(sp)
   c1d44:	df000415 	stw	fp,16(sp)
   c1d48:	df000404 	addi	fp,sp,16
   c1d4c:	e13ffe15 	stw	r4,-8(fp)
   c1d50:	e17ffd15 	stw	r5,-12(fp)
   c1d54:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   c1d58:	e0bffe17 	ldw	r2,-8(fp)
   c1d5c:	10800017 	ldw	r2,0(r2)
   c1d60:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   c1d64:	e0bfff17 	ldw	r2,-4(fp)
   c1d68:	10c00a04 	addi	r3,r2,40
   c1d6c:	e0bffe17 	ldw	r2,-8(fp)
   c1d70:	10800217 	ldw	r2,8(r2)
   c1d74:	100f883a 	mov	r7,r2
   c1d78:	e1bffc17 	ldw	r6,-16(fp)
   c1d7c:	e17ffd17 	ldw	r5,-12(fp)
   c1d80:	1809883a 	mov	r4,r3
   c1d84:	00c1e880 	call	c1e88 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   c1d88:	e037883a 	mov	sp,fp
   c1d8c:	dfc00117 	ldw	ra,4(sp)
   c1d90:	df000017 	ldw	fp,0(sp)
   c1d94:	dec00204 	addi	sp,sp,8
   c1d98:	f800283a 	ret

000c1d9c <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
   c1d9c:	defff704 	addi	sp,sp,-36
   c1da0:	df000815 	stw	fp,32(sp)
   c1da4:	df000804 	addi	fp,sp,32
   c1da8:	e13ffb15 	stw	r4,-20(fp)
   c1dac:	e17ffa15 	stw	r5,-24(fp)
   c1db0:	e1bff915 	stw	r6,-28(fp)
   c1db4:	e1fff815 	stw	r7,-32(fp)
  unsigned int base = sp->base;
   c1db8:	e0bffb17 	ldw	r2,-20(fp)
   c1dbc:	10800017 	ldw	r2,0(r2)
   c1dc0:	e0bffe15 	stw	r2,-8(fp)

  char * ptr = buffer;
   c1dc4:	e0bffa17 	ldw	r2,-24(fp)
   c1dc8:	e0bfff15 	stw	r2,-4(fp)
  char * end = buffer + space;
   c1dcc:	e0bff917 	ldw	r2,-28(fp)
   c1dd0:	e0fffa17 	ldw	r3,-24(fp)
   c1dd4:	1885883a 	add	r2,r3,r2
   c1dd8:	e0bffd15 	stw	r2,-12(fp)

  while (ptr < end)
   c1ddc:	00001206 	br	c1e28 <altera_avalon_jtag_uart_read+0x8c>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   c1de0:	e0bffe17 	ldw	r2,-8(fp)
   c1de4:	10800037 	ldwio	r2,0(r2)
   c1de8:	e0bffc15 	stw	r2,-16(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
   c1dec:	e0bffc17 	ldw	r2,-16(fp)
   c1df0:	10a0000c 	andi	r2,r2,32768
   c1df4:	10000626 	beq	r2,zero,c1e10 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   c1df8:	e0bfff17 	ldw	r2,-4(fp)
   c1dfc:	10c00044 	addi	r3,r2,1
   c1e00:	e0ffff15 	stw	r3,-4(fp)
   c1e04:	e0fffc17 	ldw	r3,-16(fp)
   c1e08:	10c00005 	stb	r3,0(r2)
   c1e0c:	00000606 	br	c1e28 <altera_avalon_jtag_uart_read+0x8c>
    else if (ptr != buffer)
   c1e10:	e0ffff17 	ldw	r3,-4(fp)
   c1e14:	e0bffa17 	ldw	r2,-24(fp)
   c1e18:	1880071e 	bne	r3,r2,c1e38 <altera_avalon_jtag_uart_read+0x9c>
      break;
    else if(flags & O_NONBLOCK)
   c1e1c:	e0bff817 	ldw	r2,-32(fp)
   c1e20:	1090000c 	andi	r2,r2,16384
   c1e24:	1000061e 	bne	r2,zero,c1e40 <altera_avalon_jtag_uart_read+0xa4>
  while (ptr < end)
   c1e28:	e0ffff17 	ldw	r3,-4(fp)
   c1e2c:	e0bffd17 	ldw	r2,-12(fp)
   c1e30:	18bfeb36 	bltu	r3,r2,c1de0 <altera_avalon_jtag_uart_read+0x44>
   c1e34:	00000306 	br	c1e44 <altera_avalon_jtag_uart_read+0xa8>
      break;
   c1e38:	0001883a 	nop
   c1e3c:	00000106 	br	c1e44 <altera_avalon_jtag_uart_read+0xa8>
      break;   
   c1e40:	0001883a 	nop
    
  }

  if (ptr != buffer)
   c1e44:	e0ffff17 	ldw	r3,-4(fp)
   c1e48:	e0bffa17 	ldw	r2,-24(fp)
   c1e4c:	18800426 	beq	r3,r2,c1e60 <altera_avalon_jtag_uart_read+0xc4>
    return ptr - buffer;
   c1e50:	e0ffff17 	ldw	r3,-4(fp)
   c1e54:	e0bffa17 	ldw	r2,-24(fp)
   c1e58:	1885c83a 	sub	r2,r3,r2
   c1e5c:	00000606 	br	c1e78 <altera_avalon_jtag_uart_read+0xdc>
  else if (flags & O_NONBLOCK)
   c1e60:	e0bff817 	ldw	r2,-32(fp)
   c1e64:	1090000c 	andi	r2,r2,16384
   c1e68:	10000226 	beq	r2,zero,c1e74 <altera_avalon_jtag_uart_read+0xd8>
    return -EWOULDBLOCK;
   c1e6c:	00bffd44 	movi	r2,-11
   c1e70:	00000106 	br	c1e78 <altera_avalon_jtag_uart_read+0xdc>
  else
    return -EIO;
   c1e74:	00bffec4 	movi	r2,-5
}
   c1e78:	e037883a 	mov	sp,fp
   c1e7c:	df000017 	ldw	fp,0(sp)
   c1e80:	dec00104 	addi	sp,sp,4
   c1e84:	f800283a 	ret

000c1e88 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   c1e88:	defff904 	addi	sp,sp,-28
   c1e8c:	df000615 	stw	fp,24(sp)
   c1e90:	df000604 	addi	fp,sp,24
   c1e94:	e13ffd15 	stw	r4,-12(fp)
   c1e98:	e17ffc15 	stw	r5,-16(fp)
   c1e9c:	e1bffb15 	stw	r6,-20(fp)
   c1ea0:	e1fffa15 	stw	r7,-24(fp)
  unsigned int base = sp->base;
   c1ea4:	e0bffd17 	ldw	r2,-12(fp)
   c1ea8:	10800017 	ldw	r2,0(r2)
   c1eac:	e0bfff15 	stw	r2,-4(fp)

  const char * end = ptr + count;
   c1eb0:	e0bffb17 	ldw	r2,-20(fp)
   c1eb4:	e0fffc17 	ldw	r3,-16(fp)
   c1eb8:	1885883a 	add	r2,r3,r2
   c1ebc:	e0bffe15 	stw	r2,-8(fp)

  while (ptr < end)
   c1ec0:	00000f06 	br	c1f00 <altera_avalon_jtag_uart_write+0x78>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   c1ec4:	e0bfff17 	ldw	r2,-4(fp)
   c1ec8:	10800104 	addi	r2,r2,4
   c1ecc:	10800037 	ldwio	r2,0(r2)
   c1ed0:	1007883a 	mov	r3,r2
   c1ed4:	00bfffd4 	movui	r2,65535
   c1ed8:	10c0092e 	bgeu	r2,r3,c1f00 <altera_avalon_jtag_uart_write+0x78>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   c1edc:	e0ffff17 	ldw	r3,-4(fp)
   c1ee0:	e0bffc17 	ldw	r2,-16(fp)
   c1ee4:	11000044 	addi	r4,r2,1
   c1ee8:	e13ffc15 	stw	r4,-16(fp)
   c1eec:	10800003 	ldbu	r2,0(r2)
   c1ef0:	10803fcc 	andi	r2,r2,255
   c1ef4:	1080201c 	xori	r2,r2,128
   c1ef8:	10bfe004 	addi	r2,r2,-128
   c1efc:	18800035 	stwio	r2,0(r3)
  while (ptr < end)
   c1f00:	e0fffc17 	ldw	r3,-16(fp)
   c1f04:	e0bffe17 	ldw	r2,-8(fp)
   c1f08:	18bfee36 	bltu	r3,r2,c1ec4 <altera_avalon_jtag_uart_write+0x3c>

  return count;
   c1f0c:	e0bffb17 	ldw	r2,-20(fp)
}
   c1f10:	e037883a 	mov	sp,fp
   c1f14:	df000017 	ldw	fp,0(sp)
   c1f18:	dec00104 	addi	sp,sp,4
   c1f1c:	f800283a 	ret

000c1f20 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   c1f20:	defff904 	addi	sp,sp,-28
   c1f24:	dfc00615 	stw	ra,24(sp)
   c1f28:	df000515 	stw	fp,20(sp)
   c1f2c:	df000504 	addi	fp,sp,20
   c1f30:	e13ffc15 	stw	r4,-16(fp)
   c1f34:	e17ffb15 	stw	r5,-20(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   c1f38:	0007883a 	mov	r3,zero
   c1f3c:	e0bffc17 	ldw	r2,-16(fp)
   c1f40:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   c1f44:	e0bffc17 	ldw	r2,-16(fp)
   c1f48:	10800104 	addi	r2,r2,4
   c1f4c:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
   c1f50:	0005303a 	rdctl	r2,status
   c1f54:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c1f58:	e0fffd17 	ldw	r3,-12(fp)
   c1f5c:	00bfff84 	movi	r2,-2
   c1f60:	1884703a 	and	r2,r3,r2
   c1f64:	1001703a 	wrctl	status,r2
  return context;
   c1f68:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   c1f6c:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
   c1f70:	00c196c0 	call	c196c <alt_tick>
   c1f74:	e0bfff17 	ldw	r2,-4(fp)
   c1f78:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
   c1f7c:	e0bffe17 	ldw	r2,-8(fp)
   c1f80:	1001703a 	wrctl	status,r2
}
   c1f84:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
   c1f88:	0001883a 	nop
   c1f8c:	e037883a 	mov	sp,fp
   c1f90:	dfc00117 	ldw	ra,4(sp)
   c1f94:	df000017 	ldw	fp,0(sp)
   c1f98:	dec00204 	addi	sp,sp,8
   c1f9c:	f800283a 	ret

000c1fa0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   c1fa0:	defff904 	addi	sp,sp,-28
   c1fa4:	dfc00615 	stw	ra,24(sp)
   c1fa8:	df000515 	stw	fp,20(sp)
   c1fac:	df000504 	addi	fp,sp,20
   c1fb0:	e13ffe15 	stw	r4,-8(fp)
   c1fb4:	e17ffd15 	stw	r5,-12(fp)
   c1fb8:	e1bffc15 	stw	r6,-16(fp)
   c1fbc:	e1fffb15 	stw	r7,-20(fp)
   c1fc0:	e0bffb17 	ldw	r2,-20(fp)
   c1fc4:	e0bfff15 	stw	r2,-4(fp)
  if (! _alt_tick_rate)
   c1fc8:	d0a0c517 	ldw	r2,-31980(gp)
   c1fcc:	1000031e 	bne	r2,zero,c1fdc <alt_avalon_timer_sc_init+0x3c>
    _alt_tick_rate = nticks;
   c1fd0:	e0bfff17 	ldw	r2,-4(fp)
   c1fd4:	d0a0c515 	stw	r2,-31980(gp)
    return 0;
   c1fd8:	00000106 	br	c1fe0 <alt_avalon_timer_sc_init+0x40>
    return -1;
   c1fdc:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   c1fe0:	e0bffe17 	ldw	r2,-8(fp)
   c1fe4:	10800104 	addi	r2,r2,4
   c1fe8:	00c001c4 	movi	r3,7
   c1fec:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
   c1ff0:	01800334 	movhi	r6,12
   c1ff4:	3187c804 	addi	r6,r6,7968
   c1ff8:	e17ffe17 	ldw	r5,-8(fp)
   c1ffc:	e13ffc17 	ldw	r4,-16(fp)
   c2000:	00c350c0 	call	c350c <alt_irq_register>
#endif  
}
   c2004:	0001883a 	nop
   c2008:	e037883a 	mov	sp,fp
   c200c:	dfc00117 	ldw	ra,4(sp)
   c2010:	df000017 	ldw	fp,0(sp)
   c2014:	dec00204 	addi	sp,sp,8
   c2018:	f800283a 	ret

000c201c <alt_up_audio_open_dev>:
#include "altera_up_avalon_audio_regs.h"

///////////////////////////////////////////////////////////////////////////
// Direct functions
alt_up_audio_dev* alt_up_audio_open_dev(const char* name)
{
   c201c:	defffc04 	addi	sp,sp,-16
   c2020:	dfc00315 	stw	ra,12(sp)
   c2024:	df000215 	stw	fp,8(sp)
   c2028:	df000204 	addi	fp,sp,8
   c202c:	e13ffe15 	stw	r4,-8(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_audio_dev *dev = (alt_up_audio_dev*)alt_find_dev(name, &alt_dev_list);
   c2030:	d1600604 	addi	r5,gp,-32744
   c2034:	e13ffe17 	ldw	r4,-8(fp)
   c2038:	00c330c0 	call	c330c <alt_find_dev>
   c203c:	e0bfff15 	stw	r2,-4(fp)
  return dev;
   c2040:	e0bfff17 	ldw	r2,-4(fp)
}
   c2044:	e037883a 	mov	sp,fp
   c2048:	dfc00117 	ldw	ra,4(sp)
   c204c:	df000017 	ldw	fp,0(sp)
   c2050:	dec00204 	addi	sp,sp,8
   c2054:	f800283a 	ret

000c2058 <alt_up_audio_enable_read_interrupt>:

void alt_up_audio_enable_read_interrupt(alt_up_audio_dev *audio)
{
   c2058:	defffd04 	addi	sp,sp,-12
   c205c:	df000215 	stw	fp,8(sp)
   c2060:	df000204 	addi	fp,sp,8
   c2064:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c2068:	e0bffe17 	ldw	r2,-8(fp)
   c206c:	10800a17 	ldw	r2,40(r2)
   c2070:	10800037 	ldwio	r2,0(r2)
   c2074:	e0bfff15 	stw	r2,-4(fp)
	// set RE to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_RE_MSK;
   c2078:	e0bfff17 	ldw	r2,-4(fp)
   c207c:	10800054 	ori	r2,r2,1
   c2080:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c2084:	e0bffe17 	ldw	r2,-8(fp)
   c2088:	10800a17 	ldw	r2,40(r2)
   c208c:	1007883a 	mov	r3,r2
   c2090:	e0bfff17 	ldw	r2,-4(fp)
   c2094:	18800035 	stwio	r2,0(r3)
}
   c2098:	0001883a 	nop
   c209c:	e037883a 	mov	sp,fp
   c20a0:	df000017 	ldw	fp,0(sp)
   c20a4:	dec00104 	addi	sp,sp,4
   c20a8:	f800283a 	ret

000c20ac <alt_up_audio_disable_read_interrupt>:

void alt_up_audio_disable_read_interrupt(alt_up_audio_dev *audio)
{
   c20ac:	defffd04 	addi	sp,sp,-12
   c20b0:	df000215 	stw	fp,8(sp)
   c20b4:	df000204 	addi	fp,sp,8
   c20b8:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c20bc:	e0bffe17 	ldw	r2,-8(fp)
   c20c0:	10800a17 	ldw	r2,40(r2)
   c20c4:	10800037 	ldwio	r2,0(r2)
   c20c8:	e0bfff15 	stw	r2,-4(fp)
	// set RE to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_RE_MSK;
   c20cc:	e0ffff17 	ldw	r3,-4(fp)
   c20d0:	00bfff84 	movi	r2,-2
   c20d4:	1884703a 	and	r2,r3,r2
   c20d8:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c20dc:	e0bffe17 	ldw	r2,-8(fp)
   c20e0:	10800a17 	ldw	r2,40(r2)
   c20e4:	1007883a 	mov	r3,r2
   c20e8:	e0bfff17 	ldw	r2,-4(fp)
   c20ec:	18800035 	stwio	r2,0(r3)
}
   c20f0:	0001883a 	nop
   c20f4:	e037883a 	mov	sp,fp
   c20f8:	df000017 	ldw	fp,0(sp)
   c20fc:	dec00104 	addi	sp,sp,4
   c2100:	f800283a 	ret

000c2104 <alt_up_audio_enable_write_interrupt>:

void alt_up_audio_enable_write_interrupt(alt_up_audio_dev *audio)
{
   c2104:	defffd04 	addi	sp,sp,-12
   c2108:	df000215 	stw	fp,8(sp)
   c210c:	df000204 	addi	fp,sp,8
   c2110:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c2114:	e0bffe17 	ldw	r2,-8(fp)
   c2118:	10800a17 	ldw	r2,40(r2)
   c211c:	10800037 	ldwio	r2,0(r2)
   c2120:	e0bfff15 	stw	r2,-4(fp)
	// set WE to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_WE_MSK;
   c2124:	e0bfff17 	ldw	r2,-4(fp)
   c2128:	10800094 	ori	r2,r2,2
   c212c:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c2130:	e0bffe17 	ldw	r2,-8(fp)
   c2134:	10800a17 	ldw	r2,40(r2)
   c2138:	1007883a 	mov	r3,r2
   c213c:	e0bfff17 	ldw	r2,-4(fp)
   c2140:	18800035 	stwio	r2,0(r3)
}
   c2144:	0001883a 	nop
   c2148:	e037883a 	mov	sp,fp
   c214c:	df000017 	ldw	fp,0(sp)
   c2150:	dec00104 	addi	sp,sp,4
   c2154:	f800283a 	ret

000c2158 <alt_up_audio_disable_write_interrupt>:

void alt_up_audio_disable_write_interrupt(alt_up_audio_dev *audio)
{
   c2158:	defffd04 	addi	sp,sp,-12
   c215c:	df000215 	stw	fp,8(sp)
   c2160:	df000204 	addi	fp,sp,8
   c2164:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c2168:	e0bffe17 	ldw	r2,-8(fp)
   c216c:	10800a17 	ldw	r2,40(r2)
   c2170:	10800037 	ldwio	r2,0(r2)
   c2174:	e0bfff15 	stw	r2,-4(fp)
	// set WE to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_WE_MSK;
   c2178:	e0ffff17 	ldw	r3,-4(fp)
   c217c:	00bfff44 	movi	r2,-3
   c2180:	1884703a 	and	r2,r3,r2
   c2184:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c2188:	e0bffe17 	ldw	r2,-8(fp)
   c218c:	10800a17 	ldw	r2,40(r2)
   c2190:	1007883a 	mov	r3,r2
   c2194:	e0bfff17 	ldw	r2,-4(fp)
   c2198:	18800035 	stwio	r2,0(r3)
}
   c219c:	0001883a 	nop
   c21a0:	e037883a 	mov	sp,fp
   c21a4:	df000017 	ldw	fp,0(sp)
   c21a8:	dec00104 	addi	sp,sp,4
   c21ac:	f800283a 	ret

000c21b0 <alt_up_audio_read_interrupt_pending>:

int alt_up_audio_read_interrupt_pending(alt_up_audio_dev *audio)
{
   c21b0:	defffd04 	addi	sp,sp,-12
   c21b4:	df000215 	stw	fp,8(sp)
   c21b8:	df000204 	addi	fp,sp,8
   c21bc:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c21c0:	e0bffe17 	ldw	r2,-8(fp)
   c21c4:	10800a17 	ldw	r2,40(r2)
   c21c8:	10800037 	ldwio	r2,0(r2)
   c21cc:	e0bfff15 	stw	r2,-4(fp)
	// return 1 if RI is set to 1
	return ( (ctrl_reg & ALT_UP_AUDIO_CONTROL_RI_MSK) ? 1 : 0 );
   c21d0:	e0bfff17 	ldw	r2,-4(fp)
   c21d4:	1004d23a 	srli	r2,r2,8
   c21d8:	1080004c 	andi	r2,r2,1
}
   c21dc:	e037883a 	mov	sp,fp
   c21e0:	df000017 	ldw	fp,0(sp)
   c21e4:	dec00104 	addi	sp,sp,4
   c21e8:	f800283a 	ret

000c21ec <alt_up_audio_write_interrupt_pending>:

int alt_up_audio_write_interrupt_pending(alt_up_audio_dev *audio)
{
   c21ec:	defffd04 	addi	sp,sp,-12
   c21f0:	df000215 	stw	fp,8(sp)
   c21f4:	df000204 	addi	fp,sp,8
   c21f8:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c21fc:	e0bffe17 	ldw	r2,-8(fp)
   c2200:	10800a17 	ldw	r2,40(r2)
   c2204:	10800037 	ldwio	r2,0(r2)
   c2208:	e0bfff15 	stw	r2,-4(fp)
	// return the WI value
	return ( (ctrl_reg & ALT_UP_AUDIO_CONTROL_WI_MSK) ? 1 : 0 );
   c220c:	e0bfff17 	ldw	r2,-4(fp)
   c2210:	1004d27a 	srli	r2,r2,9
   c2214:	1080004c 	andi	r2,r2,1
}
   c2218:	e037883a 	mov	sp,fp
   c221c:	df000017 	ldw	fp,0(sp)
   c2220:	dec00104 	addi	sp,sp,4
   c2224:	f800283a 	ret

000c2228 <alt_up_audio_reset_audio_core>:

void alt_up_audio_reset_audio_core(alt_up_audio_dev *audio)
{
   c2228:	defffd04 	addi	sp,sp,-12
   c222c:	df000215 	stw	fp,8(sp)
   c2230:	df000204 	addi	fp,sp,8
   c2234:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
   c2238:	e0bffe17 	ldw	r2,-8(fp)
   c223c:	10800a17 	ldw	r2,40(r2)
   c2240:	10800037 	ldwio	r2,0(r2)
   c2244:	e0bfff15 	stw	r2,-4(fp)
	// set CR and CW to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_CR_MSK;
   c2248:	e0bfff17 	ldw	r2,-4(fp)
   c224c:	10800114 	ori	r2,r2,4
   c2250:	e0bfff15 	stw	r2,-4(fp)
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_CW_MSK;
   c2254:	e0bfff17 	ldw	r2,-4(fp)
   c2258:	10800214 	ori	r2,r2,8
   c225c:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c2260:	e0bffe17 	ldw	r2,-8(fp)
   c2264:	10800a17 	ldw	r2,40(r2)
   c2268:	1007883a 	mov	r3,r2
   c226c:	e0bfff17 	ldw	r2,-4(fp)
   c2270:	18800035 	stwio	r2,0(r3)
	// set CR and CW to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_CR_MSK;
   c2274:	e0ffff17 	ldw	r3,-4(fp)
   c2278:	00bffec4 	movi	r2,-5
   c227c:	1884703a 	and	r2,r3,r2
   c2280:	e0bfff15 	stw	r2,-4(fp)
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_CW_MSK;
   c2284:	e0ffff17 	ldw	r3,-4(fp)
   c2288:	00bffdc4 	movi	r2,-9
   c228c:	1884703a 	and	r2,r3,r2
   c2290:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
   c2294:	e0bffe17 	ldw	r2,-8(fp)
   c2298:	10800a17 	ldw	r2,40(r2)
   c229c:	1007883a 	mov	r3,r2
   c22a0:	e0bfff17 	ldw	r2,-4(fp)
   c22a4:	18800035 	stwio	r2,0(r3)
}
   c22a8:	0001883a 	nop
   c22ac:	e037883a 	mov	sp,fp
   c22b0:	df000017 	ldw	fp,0(sp)
   c22b4:	dec00104 	addi	sp,sp,4
   c22b8:	f800283a 	ret

000c22bc <alt_up_audio_read_fifo_avail>:

/* Provides number of words of data available in the incoming FIFO: RALC or RARC */
unsigned int alt_up_audio_read_fifo_avail(alt_up_audio_dev *audio, int channel)
{
   c22bc:	defffc04 	addi	sp,sp,-16
   c22c0:	df000315 	stw	fp,12(sp)
   c22c4:	df000304 	addi	fp,sp,12
   c22c8:	e13ffe15 	stw	r4,-8(fp)
   c22cc:	e17ffd15 	stw	r5,-12(fp)
	unsigned int fifospace;
	// read the whole fifospace register
	fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
   c22d0:	e0bffe17 	ldw	r2,-8(fp)
   c22d4:	10800a17 	ldw	r2,40(r2)
   c22d8:	10800104 	addi	r2,r2,4
   c22dc:	10800037 	ldwio	r2,0(r2)
   c22e0:	e0bfff15 	stw	r2,-4(fp)
	// extract the part for proper Channel Read Space
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST :
   c22e4:	e0bffd17 	ldw	r2,-12(fp)
   c22e8:	1000041e 	bne	r2,zero,c22fc <alt_up_audio_read_fifo_avail+0x40>
   c22ec:	e0bfff17 	ldw	r2,-4(fp)
   c22f0:	1004d23a 	srli	r2,r2,8
   c22f4:	10803fcc 	andi	r2,r2,255
   c22f8:	00000206 	br	c2304 <alt_up_audio_read_fifo_avail+0x48>
   c22fc:	e0bfff17 	ldw	r2,-4(fp)
   c2300:	10803fcc 	andi	r2,r2,255
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
   c2304:	e0bfff15 	stw	r2,-4(fp)
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_RARC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RARC_OFST;
	return (fifospace);
   c2308:	e0bfff17 	ldw	r2,-4(fp)
}
   c230c:	e037883a 	mov	sp,fp
   c2310:	df000017 	ldw	fp,0(sp)
   c2314:	dec00104 	addi	sp,sp,4
   c2318:	f800283a 	ret

000c231c <alt_up_audio_record_r>:
/* Checks if the read FIFO for the right channel has at least BUF_THRESHOLD data words 
 * available. If it doesn't, then just returns 0. If it does, then data is read from the
 * FIFO up to a maximum of len words, and stored into buf.
 */
unsigned int alt_up_audio_record_r(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
   c231c:	defffa04 	addi	sp,sp,-24
   c2320:	dfc00515 	stw	ra,20(sp)
   c2324:	df000415 	stw	fp,16(sp)
   c2328:	df000404 	addi	fp,sp,16
   c232c:	e13ffe15 	stw	r4,-8(fp)
   c2330:	e17ffd15 	stw	r5,-12(fp)
   c2334:	e1bffc15 	stw	r6,-16(fp)
	unsigned int data_words = alt_up_audio_read_fifo_avail (audio, ALT_UP_AUDIO_RIGHT);
   c2338:	01400044 	movi	r5,1
   c233c:	e13ffe17 	ldw	r4,-8(fp)
   c2340:	00c22bc0 	call	c22bc <alt_up_audio_read_fifo_avail>
   c2344:	e0bfff15 	stw	r2,-4(fp)
	if (data_words <= BUF_THRESHOLD)
   c2348:	e0bfff17 	ldw	r2,-4(fp)
   c234c:	10801868 	cmpgeui	r2,r2,97
   c2350:	1000021e 	bne	r2,zero,c235c <alt_up_audio_record_r+0x40>
		return 0;
   c2354:	0005883a 	mov	r2,zero
   c2358:	00000506 	br	c2370 <alt_up_audio_record_r+0x54>
	else
		return (alt_up_audio_read_fifo(audio, buf, len, ALT_UP_AUDIO_RIGHT));
   c235c:	01c00044 	movi	r7,1
   c2360:	e1bffc17 	ldw	r6,-16(fp)
   c2364:	e17ffd17 	ldw	r5,-12(fp)
   c2368:	e13ffe17 	ldw	r4,-8(fp)
   c236c:	00c251c0 	call	c251c <alt_up_audio_read_fifo>
}
   c2370:	e037883a 	mov	sp,fp
   c2374:	dfc00117 	ldw	ra,4(sp)
   c2378:	df000017 	ldw	fp,0(sp)
   c237c:	dec00204 	addi	sp,sp,8
   c2380:	f800283a 	ret

000c2384 <alt_up_audio_record_l>:
/* Checks if the read FIFO for the left channel has at least BUF_THRESHOLD data words 
 * available. If it doesn't, then just returns 0. If it does, then data is read from the
 * FIFO up to a maximum of len words, and stored into buf.
 */
unsigned int alt_up_audio_record_l(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
   c2384:	defffa04 	addi	sp,sp,-24
   c2388:	dfc00515 	stw	ra,20(sp)
   c238c:	df000415 	stw	fp,16(sp)
   c2390:	df000404 	addi	fp,sp,16
   c2394:	e13ffe15 	stw	r4,-8(fp)
   c2398:	e17ffd15 	stw	r5,-12(fp)
   c239c:	e1bffc15 	stw	r6,-16(fp)
	unsigned int data_words = alt_up_audio_read_fifo_avail (audio, ALT_UP_AUDIO_LEFT);
   c23a0:	000b883a 	mov	r5,zero
   c23a4:	e13ffe17 	ldw	r4,-8(fp)
   c23a8:	00c22bc0 	call	c22bc <alt_up_audio_read_fifo_avail>
   c23ac:	e0bfff15 	stw	r2,-4(fp)
	if (data_words <= BUF_THRESHOLD)
   c23b0:	e0bfff17 	ldw	r2,-4(fp)
   c23b4:	10801868 	cmpgeui	r2,r2,97
   c23b8:	1000021e 	bne	r2,zero,c23c4 <alt_up_audio_record_l+0x40>
		return 0;
   c23bc:	0005883a 	mov	r2,zero
   c23c0:	00000506 	br	c23d8 <alt_up_audio_record_l+0x54>
	else
		return (alt_up_audio_read_fifo(audio, buf, len, ALT_UP_AUDIO_LEFT));
   c23c4:	000f883a 	mov	r7,zero
   c23c8:	e1bffc17 	ldw	r6,-16(fp)
   c23cc:	e17ffd17 	ldw	r5,-12(fp)
   c23d0:	e13ffe17 	ldw	r4,-8(fp)
   c23d4:	00c251c0 	call	c251c <alt_up_audio_read_fifo>
}
   c23d8:	e037883a 	mov	sp,fp
   c23dc:	dfc00117 	ldw	ra,4(sp)
   c23e0:	df000017 	ldw	fp,0(sp)
   c23e4:	dec00204 	addi	sp,sp,8
   c23e8:	f800283a 	ret

000c23ec <alt_up_audio_write_fifo_space>:

/* Provides the amount of empty space available in the outgoing FIFO: WSLC or WSRC */
unsigned int alt_up_audio_write_fifo_space(alt_up_audio_dev *audio, int channel)
{
   c23ec:	defffc04 	addi	sp,sp,-16
   c23f0:	df000315 	stw	fp,12(sp)
   c23f4:	df000304 	addi	fp,sp,12
   c23f8:	e13ffe15 	stw	r4,-8(fp)
   c23fc:	e17ffd15 	stw	r5,-12(fp)
	unsigned int fifospace;
	// read the whole fifospace register
	fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
   c2400:	e0bffe17 	ldw	r2,-8(fp)
   c2404:	10800a17 	ldw	r2,40(r2)
   c2408:	10800104 	addi	r2,r2,4
   c240c:	10800037 	ldwio	r2,0(r2)
   c2410:	e0bfff15 	stw	r2,-4(fp)
	// extract the part for proper Channel Read Space
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
   c2414:	e0bffd17 	ldw	r2,-12(fp)
   c2418:	1000031e 	bne	r2,zero,c2428 <alt_up_audio_write_fifo_space+0x3c>
   c241c:	e0bfff17 	ldw	r2,-4(fp)
   c2420:	1004d63a 	srli	r2,r2,24
   c2424:	00000306 	br	c2434 <alt_up_audio_write_fifo_space+0x48>
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSRC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSRC_OFST;
   c2428:	e0bfff17 	ldw	r2,-4(fp)
   c242c:	1004d43a 	srli	r2,r2,16
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
   c2430:	10803fcc 	andi	r2,r2,255
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
   c2434:	e0bfff15 	stw	r2,-4(fp)
	return (fifospace);
   c2438:	e0bfff17 	ldw	r2,-4(fp)
}
   c243c:	e037883a 	mov	sp,fp
   c2440:	df000017 	ldw	fp,0(sp)
   c2444:	dec00104 	addi	sp,sp,4
   c2448:	f800283a 	ret

000c244c <alt_up_audio_play_r>:
/* Checks if the write FIFO for the right channel has at least BUF_THRESHOLD space available.
 * If it doesn't, then just returns 0. If it does, then data from buf is written into the 
 * FIFO, up to a maximum of len words.
 */
unsigned int alt_up_audio_play_r(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
   c244c:	defffa04 	addi	sp,sp,-24
   c2450:	dfc00515 	stw	ra,20(sp)
   c2454:	df000415 	stw	fp,16(sp)
   c2458:	df000404 	addi	fp,sp,16
   c245c:	e13ffe15 	stw	r4,-8(fp)
   c2460:	e17ffd15 	stw	r5,-12(fp)
   c2464:	e1bffc15 	stw	r6,-16(fp)
	unsigned int space = alt_up_audio_write_fifo_space (audio, ALT_UP_AUDIO_RIGHT);
   c2468:	01400044 	movi	r5,1
   c246c:	e13ffe17 	ldw	r4,-8(fp)
   c2470:	00c23ec0 	call	c23ec <alt_up_audio_write_fifo_space>
   c2474:	e0bfff15 	stw	r2,-4(fp)
	if (space <= BUF_THRESHOLD)
   c2478:	e0bfff17 	ldw	r2,-4(fp)
   c247c:	10801868 	cmpgeui	r2,r2,97
   c2480:	1000021e 	bne	r2,zero,c248c <alt_up_audio_play_r+0x40>
		return 0;
   c2484:	0005883a 	mov	r2,zero
   c2488:	00000506 	br	c24a0 <alt_up_audio_play_r+0x54>
	else
		return (alt_up_audio_write_fifo(audio, buf, len, ALT_UP_AUDIO_RIGHT));
   c248c:	01c00044 	movi	r7,1
   c2490:	e1bffc17 	ldw	r6,-16(fp)
   c2494:	e17ffd17 	ldw	r5,-12(fp)
   c2498:	e13ffe17 	ldw	r4,-8(fp)
   c249c:	00c25fc0 	call	c25fc <alt_up_audio_write_fifo>
}
   c24a0:	e037883a 	mov	sp,fp
   c24a4:	dfc00117 	ldw	ra,4(sp)
   c24a8:	df000017 	ldw	fp,0(sp)
   c24ac:	dec00204 	addi	sp,sp,8
   c24b0:	f800283a 	ret

000c24b4 <alt_up_audio_play_l>:
/* Checks if the write FIFO for the left channel has at least BUF_THRESHOLD space available.
 * If it doesn't, then just returns 0. If it does, then data from buf is written into the 
 * FIFO, up to a maximum of len words.
 */
unsigned int alt_up_audio_play_l(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
   c24b4:	defffa04 	addi	sp,sp,-24
   c24b8:	dfc00515 	stw	ra,20(sp)
   c24bc:	df000415 	stw	fp,16(sp)
   c24c0:	df000404 	addi	fp,sp,16
   c24c4:	e13ffe15 	stw	r4,-8(fp)
   c24c8:	e17ffd15 	stw	r5,-12(fp)
   c24cc:	e1bffc15 	stw	r6,-16(fp)
	unsigned int space = alt_up_audio_write_fifo_space (audio, ALT_UP_AUDIO_LEFT);
   c24d0:	000b883a 	mov	r5,zero
   c24d4:	e13ffe17 	ldw	r4,-8(fp)
   c24d8:	00c23ec0 	call	c23ec <alt_up_audio_write_fifo_space>
   c24dc:	e0bfff15 	stw	r2,-4(fp)
	if (space <= BUF_THRESHOLD)
   c24e0:	e0bfff17 	ldw	r2,-4(fp)
   c24e4:	10801868 	cmpgeui	r2,r2,97
   c24e8:	1000021e 	bne	r2,zero,c24f4 <alt_up_audio_play_l+0x40>
		return 0;
   c24ec:	0005883a 	mov	r2,zero
   c24f0:	00000506 	br	c2508 <alt_up_audio_play_l+0x54>
	else
		return (alt_up_audio_write_fifo(audio, buf, len, ALT_UP_AUDIO_LEFT));
   c24f4:	000f883a 	mov	r7,zero
   c24f8:	e1bffc17 	ldw	r6,-16(fp)
   c24fc:	e17ffd17 	ldw	r5,-12(fp)
   c2500:	e13ffe17 	ldw	r4,-8(fp)
   c2504:	00c25fc0 	call	c25fc <alt_up_audio_write_fifo>
}
   c2508:	e037883a 	mov	sp,fp
   c250c:	dfc00117 	ldw	ra,4(sp)
   c2510:	df000017 	ldw	fp,0(sp)
   c2514:	dec00204 	addi	sp,sp,8
   c2518:	f800283a 	ret

000c251c <alt_up_audio_read_fifo>:

int alt_up_audio_read_fifo(alt_up_audio_dev *audio, unsigned int *buf, int len, int channel)
{
   c251c:	defff904 	addi	sp,sp,-28
   c2520:	df000615 	stw	fp,24(sp)
   c2524:	df000604 	addi	fp,sp,24
   c2528:	e13ffd15 	stw	r4,-12(fp)
   c252c:	e17ffc15 	stw	r5,-16(fp)
   c2530:	e1bffb15 	stw	r6,-20(fp)
   c2534:	e1fffa15 	stw	r7,-24(fp)
	unsigned int fifospace;
	int count = 0;
   c2538:	e03fff15 	stw	zero,-4(fp)
	while ( count < len ) 
   c253c:	00002506 	br	c25d4 <alt_up_audio_read_fifo+0xb8>
	{
		// read the whole fifospace register
		fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
   c2540:	e0bffd17 	ldw	r2,-12(fp)
   c2544:	10800a17 	ldw	r2,40(r2)
   c2548:	10800104 	addi	r2,r2,4
   c254c:	10800037 	ldwio	r2,0(r2)
   c2550:	e0bffe15 	stw	r2,-8(fp)
		// extract the part for proper Channel Read Space
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST 
			:
   c2554:	e0bffa17 	ldw	r2,-24(fp)
   c2558:	1000041e 	bne	r2,zero,c256c <alt_up_audio_read_fifo+0x50>
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST 
   c255c:	e0bffe17 	ldw	r2,-8(fp)
   c2560:	1004d23a 	srli	r2,r2,8
			:
   c2564:	10803fcc 	andi	r2,r2,255
   c2568:	00000206 	br	c2574 <alt_up_audio_read_fifo+0x58>
   c256c:	e0bffe17 	ldw	r2,-8(fp)
   c2570:	10803fcc 	andi	r2,r2,255
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
   c2574:	e0bffe15 	stw	r2,-8(fp)
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RARC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RARC_OFST;
		if (fifospace > 0) 
   c2578:	e0bffe17 	ldw	r2,-8(fp)
   c257c:	10001926 	beq	r2,zero,c25e4 <alt_up_audio_read_fifo+0xc8>
		{
			buf[count] = (channel == ALT_UP_AUDIO_LEFT) ? 
				IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
   c2580:	e0bffa17 	ldw	r2,-24(fp)
   c2584:	1000061e 	bne	r2,zero,c25a0 <alt_up_audio_read_fifo+0x84>
   c2588:	e0bffd17 	ldw	r2,-12(fp)
   c258c:	10800a17 	ldw	r2,40(r2)
   c2590:	10800204 	addi	r2,r2,8
   c2594:	10800037 	ldwio	r2,0(r2)
   c2598:	1009883a 	mov	r4,r2
   c259c:	00000506 	br	c25b4 <alt_up_audio_read_fifo+0x98>
				IORD_ALT_UP_AUDIO_RIGHTDATA(audio->base);
   c25a0:	e0bffd17 	ldw	r2,-12(fp)
   c25a4:	10800a17 	ldw	r2,40(r2)
   c25a8:	10800304 	addi	r2,r2,12
   c25ac:	10800037 	ldwio	r2,0(r2)
				IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
   c25b0:	1009883a 	mov	r4,r2
			buf[count] = (channel == ALT_UP_AUDIO_LEFT) ? 
   c25b4:	e0bfff17 	ldw	r2,-4(fp)
   c25b8:	100490ba 	slli	r2,r2,2
   c25bc:	e0fffc17 	ldw	r3,-16(fp)
   c25c0:	1885883a 	add	r2,r3,r2
   c25c4:	11000015 	stw	r4,0(r2)
			count ++;
   c25c8:	e0bfff17 	ldw	r2,-4(fp)
   c25cc:	10800044 	addi	r2,r2,1
   c25d0:	e0bfff15 	stw	r2,-4(fp)
	while ( count < len ) 
   c25d4:	e0ffff17 	ldw	r3,-4(fp)
   c25d8:	e0bffb17 	ldw	r2,-20(fp)
   c25dc:	18bfd816 	blt	r3,r2,c2540 <alt_up_audio_read_fifo+0x24>
   c25e0:	00000106 	br	c25e8 <alt_up_audio_read_fifo+0xcc>
		}
		else
		{
			// no more data to read
			break;
   c25e4:	0001883a 	nop
		}
	}
	return count;
   c25e8:	e0bfff17 	ldw	r2,-4(fp)
}
   c25ec:	e037883a 	mov	sp,fp
   c25f0:	df000017 	ldw	fp,0(sp)
   c25f4:	dec00104 	addi	sp,sp,4
   c25f8:	f800283a 	ret

000c25fc <alt_up_audio_write_fifo>:

int alt_up_audio_write_fifo(alt_up_audio_dev *audio, unsigned int *buf, int len, int channel)
{
   c25fc:	defff904 	addi	sp,sp,-28
   c2600:	df000615 	stw	fp,24(sp)
   c2604:	df000604 	addi	fp,sp,24
   c2608:	e13ffd15 	stw	r4,-12(fp)
   c260c:	e17ffc15 	stw	r5,-16(fp)
   c2610:	e1bffb15 	stw	r6,-20(fp)
   c2614:	e1fffa15 	stw	r7,-24(fp)
	unsigned int fifospace;
	int count = 0;
   c2618:	e03fff15 	stw	zero,-4(fp)
	while ( count < len ) 
   c261c:	00002b06 	br	c26cc <alt_up_audio_write_fifo+0xd0>
	{
		// read the whole fifospace register
		fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
   c2620:	e0bffd17 	ldw	r2,-12(fp)
   c2624:	10800a17 	ldw	r2,40(r2)
   c2628:	10800104 	addi	r2,r2,4
   c262c:	10800037 	ldwio	r2,0(r2)
   c2630:	e0bffe15 	stw	r2,-8(fp)
		// extract the part for Left Channel Write Space 
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
   c2634:	e0bffa17 	ldw	r2,-24(fp)
   c2638:	1000031e 	bne	r2,zero,c2648 <alt_up_audio_write_fifo+0x4c>
   c263c:	e0bffe17 	ldw	r2,-8(fp)
   c2640:	1004d63a 	srli	r2,r2,24
   c2644:	00000306 	br	c2654 <alt_up_audio_write_fifo+0x58>
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSRC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSRC_OFST;
   c2648:	e0bffe17 	ldw	r2,-8(fp)
   c264c:	1004d43a 	srli	r2,r2,16
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
   c2650:	10803fcc 	andi	r2,r2,255
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
   c2654:	e0bffe15 	stw	r2,-8(fp)
		if (fifospace > 0) 
   c2658:	e0bffe17 	ldw	r2,-8(fp)
   c265c:	10001f26 	beq	r2,zero,c26dc <alt_up_audio_write_fifo+0xe0>
		{
			if (channel == ALT_UP_AUDIO_LEFT) 
   c2660:	e0bffa17 	ldw	r2,-24(fp)
   c2664:	10000d1e 	bne	r2,zero,c269c <alt_up_audio_write_fifo+0xa0>
				IOWR_ALT_UP_AUDIO_LEFTDATA(audio->base, buf[count++]);
   c2668:	e0bffd17 	ldw	r2,-12(fp)
   c266c:	10800a17 	ldw	r2,40(r2)
   c2670:	10800204 	addi	r2,r2,8
   c2674:	1009883a 	mov	r4,r2
   c2678:	e0bfff17 	ldw	r2,-4(fp)
   c267c:	10c00044 	addi	r3,r2,1
   c2680:	e0ffff15 	stw	r3,-4(fp)
   c2684:	100490ba 	slli	r2,r2,2
   c2688:	e0fffc17 	ldw	r3,-16(fp)
   c268c:	1885883a 	add	r2,r3,r2
   c2690:	10800017 	ldw	r2,0(r2)
   c2694:	20800035 	stwio	r2,0(r4)
   c2698:	00000c06 	br	c26cc <alt_up_audio_write_fifo+0xd0>
			else
				IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, buf[count++]);
   c269c:	e0bffd17 	ldw	r2,-12(fp)
   c26a0:	10800a17 	ldw	r2,40(r2)
   c26a4:	10800304 	addi	r2,r2,12
   c26a8:	1009883a 	mov	r4,r2
   c26ac:	e0bfff17 	ldw	r2,-4(fp)
   c26b0:	10c00044 	addi	r3,r2,1
   c26b4:	e0ffff15 	stw	r3,-4(fp)
   c26b8:	100490ba 	slli	r2,r2,2
   c26bc:	e0fffc17 	ldw	r3,-16(fp)
   c26c0:	1885883a 	add	r2,r3,r2
   c26c4:	10800017 	ldw	r2,0(r2)
   c26c8:	20800035 	stwio	r2,0(r4)
	while ( count < len ) 
   c26cc:	e0ffff17 	ldw	r3,-4(fp)
   c26d0:	e0bffb17 	ldw	r2,-20(fp)
   c26d4:	18bfd216 	blt	r3,r2,c2620 <alt_up_audio_write_fifo+0x24>
   c26d8:	00000106 	br	c26e0 <alt_up_audio_write_fifo+0xe4>
		}
		else
		{
			// no more space to write
			break;
   c26dc:	0001883a 	nop
		}
	}
	return count;
   c26e0:	e0bfff17 	ldw	r2,-4(fp)
}
   c26e4:	e037883a 	mov	sp,fp
   c26e8:	df000017 	ldw	fp,0(sp)
   c26ec:	dec00104 	addi	sp,sp,4
   c26f0:	f800283a 	ret

000c26f4 <alt_up_audio_read_fifo_head>:

unsigned int alt_up_audio_read_fifo_head(alt_up_audio_dev *audio, int channel)
{
   c26f4:	defffd04 	addi	sp,sp,-12
   c26f8:	df000215 	stw	fp,8(sp)
   c26fc:	df000204 	addi	fp,sp,8
   c2700:	e13fff15 	stw	r4,-4(fp)
   c2704:	e17ffe15 	stw	r5,-8(fp)
	return ( (channel == ALT_UP_AUDIO_LEFT) ?  IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
   c2708:	e0bffe17 	ldw	r2,-8(fp)
   c270c:	1000051e 	bne	r2,zero,c2724 <alt_up_audio_read_fifo_head+0x30>
   c2710:	e0bfff17 	ldw	r2,-4(fp)
   c2714:	10800a17 	ldw	r2,40(r2)
   c2718:	10800204 	addi	r2,r2,8
   c271c:	10800037 	ldwio	r2,0(r2)
   c2720:	00000406 	br	c2734 <alt_up_audio_read_fifo_head+0x40>
				IORD_ALT_UP_AUDIO_RIGHTDATA(audio->base) );
   c2724:	e0bfff17 	ldw	r2,-4(fp)
   c2728:	10800a17 	ldw	r2,40(r2)
   c272c:	10800304 	addi	r2,r2,12
   c2730:	10800037 	ldwio	r2,0(r2)
}
   c2734:	e037883a 	mov	sp,fp
   c2738:	df000017 	ldw	fp,0(sp)
   c273c:	dec00104 	addi	sp,sp,4
   c2740:	f800283a 	ret

000c2744 <alt_up_audio_write_fifo_head>:

void alt_up_audio_write_fifo_head(alt_up_audio_dev *audio, unsigned int data, int channel)
{
   c2744:	defffc04 	addi	sp,sp,-16
   c2748:	df000315 	stw	fp,12(sp)
   c274c:	df000304 	addi	fp,sp,12
   c2750:	e13fff15 	stw	r4,-4(fp)
   c2754:	e17ffe15 	stw	r5,-8(fp)
   c2758:	e1bffd15 	stw	r6,-12(fp)
	if (channel == ALT_UP_AUDIO_LEFT) 
   c275c:	e0bffd17 	ldw	r2,-12(fp)
   c2760:	1000071e 	bne	r2,zero,c2780 <alt_up_audio_write_fifo_head+0x3c>
		IOWR_ALT_UP_AUDIO_LEFTDATA(audio->base, data);
   c2764:	e0bfff17 	ldw	r2,-4(fp)
   c2768:	10800a17 	ldw	r2,40(r2)
   c276c:	10800204 	addi	r2,r2,8
   c2770:	1007883a 	mov	r3,r2
   c2774:	e0bffe17 	ldw	r2,-8(fp)
   c2778:	18800035 	stwio	r2,0(r3)
	else
		IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, data);
}
   c277c:	00000606 	br	c2798 <alt_up_audio_write_fifo_head+0x54>
		IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, data);
   c2780:	e0bfff17 	ldw	r2,-4(fp)
   c2784:	10800a17 	ldw	r2,40(r2)
   c2788:	10800304 	addi	r2,r2,12
   c278c:	1007883a 	mov	r3,r2
   c2790:	e0bffe17 	ldw	r2,-8(fp)
   c2794:	18800035 	stwio	r2,0(r3)
}
   c2798:	0001883a 	nop
   c279c:	e037883a 	mov	sp,fp
   c27a0:	df000017 	ldw	fp,0(sp)
   c27a4:	dec00104 	addi	sp,sp,4
   c27a8:	f800283a 	ret

000c27ac <alt_up_av_config_open_dev>:

#include "altera_up_avalon_audio_and_video_config.h"
#include "altera_up_avalon_audio_and_video_config_regs.h"

alt_up_av_config_dev* alt_up_av_config_open_dev(const char* name)
{
   c27ac:	defffc04 	addi	sp,sp,-16
   c27b0:	dfc00315 	stw	ra,12(sp)
   c27b4:	df000215 	stw	fp,8(sp)
   c27b8:	df000204 	addi	fp,sp,8
   c27bc:	e13ffe15 	stw	r4,-8(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_av_config_dev *dev = (alt_up_av_config_dev*)alt_find_dev(name, &alt_dev_list);
   c27c0:	d1600604 	addi	r5,gp,-32744
   c27c4:	e13ffe17 	ldw	r4,-8(fp)
   c27c8:	00c330c0 	call	c330c <alt_find_dev>
   c27cc:	e0bfff15 	stw	r2,-4(fp)
  dev->type = (IORD_ALT_UP_AV_CONFIG_STATUS(dev->base) & ALT_UP_AV_CONFIG_STATUS_CFG_MSK) >> ALT_UP_AV_CONFIG_STATUS_CFG_OFST;
   c27d0:	e0bfff17 	ldw	r2,-4(fp)
   c27d4:	10800a17 	ldw	r2,40(r2)
   c27d8:	10800104 	addi	r2,r2,4
   c27dc:	10800037 	ldwio	r2,0(r2)
   c27e0:	1005d43a 	srai	r2,r2,16
   c27e4:	10803fcc 	andi	r2,r2,255
   c27e8:	1007883a 	mov	r3,r2
   c27ec:	e0bfff17 	ldw	r2,-4(fp)
   c27f0:	10c00b15 	stw	r3,44(r2)

  return dev;
   c27f4:	e0bfff17 	ldw	r2,-4(fp)
}
   c27f8:	e037883a 	mov	sp,fp
   c27fc:	dfc00117 	ldw	ra,4(sp)
   c2800:	df000017 	ldw	fp,0(sp)
   c2804:	dec00204 	addi	sp,sp,8
   c2808:	f800283a 	ret

000c280c <alt_up_av_config_write_data>:
 * @param data --  the data to be sent
 *
 * @return 0 for success
 **/
int alt_up_av_config_write_data(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data)
{
   c280c:	defffc04 	addi	sp,sp,-16
   c2810:	df000315 	stw	fp,12(sp)
   c2814:	df000304 	addi	fp,sp,12
   c2818:	e13fff15 	stw	r4,-4(fp)
   c281c:	e17ffe15 	stw	r5,-8(fp)
   c2820:	e1bffd15 	stw	r6,-12(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_AV_CONFIG_ADDRESS(av_config->base, addr & ALT_UP_AV_CONFIG_ADDRESS_VALID_MSK); 
   c2824:	e0bfff17 	ldw	r2,-4(fp)
   c2828:	10800a17 	ldw	r2,40(r2)
   c282c:	10800204 	addi	r2,r2,8
   c2830:	1007883a 	mov	r3,r2
   c2834:	e0bffe17 	ldw	r2,-8(fp)
   c2838:	10803fcc 	andi	r2,r2,255
   c283c:	18800035 	stwio	r2,0(r3)

	// write data to the device Data register
	IOWR_ALT_UP_AV_CONFIG_DATA(av_config->base, data & ALT_UP_AV_CONFIG_DATA_VALID_MSK); 
   c2840:	e0bfff17 	ldw	r2,-4(fp)
   c2844:	10800a17 	ldw	r2,40(r2)
   c2848:	10800304 	addi	r2,r2,12
   c284c:	1007883a 	mov	r3,r2
   c2850:	e0bffd17 	ldw	r2,-12(fp)
   c2854:	10bfffcc 	andi	r2,r2,65535
   c2858:	18800035 	stwio	r2,0(r3)

	return 0;
   c285c:	0005883a 	mov	r2,zero
}
   c2860:	e037883a 	mov	sp,fp
   c2864:	df000017 	ldw	fp,0(sp)
   c2868:	dec00104 	addi	sp,sp,4
   c286c:	f800283a 	ret

000c2870 <alt_up_av_config_read_data>:
 * @param data -- a pointer to the location where the read data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_av_config_read_data(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 * data)
{
   c2870:	defffb04 	addi	sp,sp,-20
   c2874:	dfc00415 	stw	ra,16(sp)
   c2878:	df000315 	stw	fp,12(sp)
   c287c:	df000304 	addi	fp,sp,12
   c2880:	e13fff15 	stw	r4,-4(fp)
   c2884:	e17ffe15 	stw	r5,-8(fp)
   c2888:	e1bffd15 	stw	r6,-12(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_AV_CONFIG_ADDRESS(av_config->base, addr & ALT_UP_AV_CONFIG_ADDRESS_VALID_MSK); 
   c288c:	e0bfff17 	ldw	r2,-4(fp)
   c2890:	10800a17 	ldw	r2,40(r2)
   c2894:	10800204 	addi	r2,r2,8
   c2898:	1007883a 	mov	r3,r2
   c289c:	e0bffe17 	ldw	r2,-8(fp)
   c28a0:	10803fcc 	andi	r2,r2,255
   c28a4:	18800035 	stwio	r2,0(r3)

	// write data to the device Data register
	*(data) = IORD_ALT_UP_AV_CONFIG_DATA(av_config->base); 
   c28a8:	e0bfff17 	ldw	r2,-4(fp)
   c28ac:	10800a17 	ldw	r2,40(r2)
   c28b0:	10800304 	addi	r2,r2,12
   c28b4:	10800037 	ldwio	r2,0(r2)
   c28b8:	1007883a 	mov	r3,r2
   c28bc:	e0bffd17 	ldw	r2,-12(fp)
   c28c0:	10c00015 	stw	r3,0(r2)

	// check acknowledge is 0
	if (alt_up_av_config_read_acknowledge(av_config))
   c28c4:	e13fff17 	ldw	r4,-4(fp)
   c28c8:	00c29940 	call	c2994 <alt_up_av_config_read_acknowledge>
   c28cc:	10000226 	beq	r2,zero,c28d8 <alt_up_av_config_read_data+0x68>
		return -1;
   c28d0:	00bfffc4 	movi	r2,-1
   c28d4:	00000106 	br	c28dc <alt_up_av_config_read_data+0x6c>

	return 0;
   c28d8:	0005883a 	mov	r2,zero
}
   c28dc:	e037883a 	mov	sp,fp
   c28e0:	dfc00117 	ldw	ra,4(sp)
   c28e4:	df000017 	ldw	fp,0(sp)
   c28e8:	dec00204 	addi	sp,sp,8
   c28ec:	f800283a 	ret

000c28f0 <alt_up_av_config_reset>:

int alt_up_av_config_reset(alt_up_av_config_dev *av_config)
{
   c28f0:	defffe04 	addi	sp,sp,-8
   c28f4:	df000115 	stw	fp,4(sp)
   c28f8:	df000104 	addi	fp,sp,4
   c28fc:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_AV_CONFIG_CONTROL_RESET(av_config->base);
   c2900:	e0bfff17 	ldw	r2,-4(fp)
   c2904:	10800a17 	ldw	r2,40(r2)
   c2908:	1007883a 	mov	r3,r2
   c290c:	00800044 	movi	r2,1
   c2910:	18800025 	stbio	r2,0(r3)
	return 0;
   c2914:	0005883a 	mov	r2,zero
}
   c2918:	e037883a 	mov	sp,fp
   c291c:	df000017 	ldw	fp,0(sp)
   c2920:	dec00104 	addi	sp,sp,4
   c2924:	f800283a 	ret

000c2928 <alt_up_av_config_enable_interrupt>:

int alt_up_av_config_enable_interrupt(alt_up_av_config_dev *av_config)
{
   c2928:	defffe04 	addi	sp,sp,-8
   c292c:	df000115 	stw	fp,4(sp)
   c2930:	df000104 	addi	fp,sp,4
   c2934:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_AV_CONFIG_CONTROL_RIE_ENABLE(av_config->base);
   c2938:	e0bfff17 	ldw	r2,-4(fp)
   c293c:	10800a17 	ldw	r2,40(r2)
   c2940:	1007883a 	mov	r3,r2
   c2944:	00800084 	movi	r2,2
   c2948:	18800025 	stbio	r2,0(r3)
	return 0;
   c294c:	0005883a 	mov	r2,zero
}
   c2950:	e037883a 	mov	sp,fp
   c2954:	df000017 	ldw	fp,0(sp)
   c2958:	dec00104 	addi	sp,sp,4
   c295c:	f800283a 	ret

000c2960 <alt_up_av_config_disable_interrupt>:

int alt_up_av_config_disable_interrupt(alt_up_av_config_dev *av_config)
{
   c2960:	defffe04 	addi	sp,sp,-8
   c2964:	df000115 	stw	fp,4(sp)
   c2968:	df000104 	addi	fp,sp,4
   c296c:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_AV_CONFIG_CONTROL_RIE_DISABLE(av_config->base);
   c2970:	e0bfff17 	ldw	r2,-4(fp)
   c2974:	10800a17 	ldw	r2,40(r2)
   c2978:	0007883a 	mov	r3,zero
   c297c:	10c00025 	stbio	r3,0(r2)
	return 0;
   c2980:	0005883a 	mov	r2,zero
}
   c2984:	e037883a 	mov	sp,fp
   c2988:	df000017 	ldw	fp,0(sp)
   c298c:	dec00104 	addi	sp,sp,4
   c2990:	f800283a 	ret

000c2994 <alt_up_av_config_read_acknowledge>:

int alt_up_av_config_read_acknowledge(alt_up_av_config_dev *av_config)
{
   c2994:	defffe04 	addi	sp,sp,-8
   c2998:	df000115 	stw	fp,4(sp)
   c299c:	df000104 	addi	fp,sp,4
   c29a0:	e13fff15 	stw	r4,-4(fp)
	if ((IORD_ALT_UP_AV_CONFIG_STATUS(av_config->base) & ALT_UP_AV_CONFIG_STATUS_RDY_MSK) >> ALT_UP_AV_CONFIG_STATUS_RDY_OFST)
   c29a4:	e0bfff17 	ldw	r2,-4(fp)
   c29a8:	10800a17 	ldw	r2,40(r2)
   c29ac:	10800104 	addi	r2,r2,4
   c29b0:	10800037 	ldwio	r2,0(r2)
   c29b4:	1080008c 	andi	r2,r2,2
   c29b8:	10000626 	beq	r2,zero,c29d4 <alt_up_av_config_read_acknowledge+0x40>
		return ((IORD_ALT_UP_AV_CONFIG_STATUS(av_config->base) & ALT_UP_AV_CONFIG_STATUS_ACK_MSK) >> ALT_UP_AV_CONFIG_STATUS_ACK_OFST);
   c29bc:	e0bfff17 	ldw	r2,-4(fp)
   c29c0:	10800a17 	ldw	r2,40(r2)
   c29c4:	10800104 	addi	r2,r2,4
   c29c8:	10800037 	ldwio	r2,0(r2)
   c29cc:	1080004c 	andi	r2,r2,1
   c29d0:	00000106 	br	c29d8 <alt_up_av_config_read_acknowledge+0x44>
	return -1;
   c29d4:	00bfffc4 	movi	r2,-1
}
   c29d8:	e037883a 	mov	sp,fp
   c29dc:	df000017 	ldw	fp,0(sp)
   c29e0:	dec00104 	addi	sp,sp,4
   c29e4:	f800283a 	ret

000c29e8 <alt_up_av_config_read_ready>:

int alt_up_av_config_read_ready(alt_up_av_config_dev *av_config)
{
   c29e8:	defffe04 	addi	sp,sp,-8
   c29ec:	df000115 	stw	fp,4(sp)
   c29f0:	df000104 	addi	fp,sp,4
   c29f4:	e13fff15 	stw	r4,-4(fp)
	return ((IORD_ALT_UP_AV_CONFIG_STATUS(av_config->base) & ALT_UP_AV_CONFIG_STATUS_RDY_MSK) >> ALT_UP_AV_CONFIG_STATUS_RDY_OFST);
   c29f8:	e0bfff17 	ldw	r2,-4(fp)
   c29fc:	10800a17 	ldw	r2,40(r2)
   c2a00:	10800104 	addi	r2,r2,4
   c2a04:	10800037 	ldwio	r2,0(r2)
   c2a08:	1005d07a 	srai	r2,r2,1
   c2a0c:	1080004c 	andi	r2,r2,1
}
   c2a10:	e037883a 	mov	sp,fp
   c2a14:	df000017 	ldw	fp,0(sp)
   c2a18:	dec00104 	addi	sp,sp,4
   c2a1c:	f800283a 	ret

000c2a20 <alt_up_av_config_write_audio_cfg_register>:

int alt_up_av_config_write_audio_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data)
{
   c2a20:	defffa04 	addi	sp,sp,-24
   c2a24:	dfc00515 	stw	ra,20(sp)
   c2a28:	df000415 	stw	fp,16(sp)
   c2a2c:	df000404 	addi	fp,sp,16
   c2a30:	e13ffe15 	stw	r4,-8(fp)
   c2a34:	e17ffd15 	stw	r5,-12(fp)
   c2a38:	e1bffc15 	stw	r6,-16(fp)
	// check the device is indeed audio configuration
	if (av_config->type != ON_BOARD_AUDIO_ONLY_CONFIG && av_config->type != ON_BOARD_DE2_CONFIG && av_config->type != ON_BOARD_DE2_70_CONFIG && av_config->type != ON_BOARD_DE2_115_CONFIG)
   c2a3c:	e0bffe17 	ldw	r2,-8(fp)
   c2a40:	10800b17 	ldw	r2,44(r2)
   c2a44:	10800060 	cmpeqi	r2,r2,1
   c2a48:	10000e1e 	bne	r2,zero,c2a84 <alt_up_av_config_write_audio_cfg_register+0x64>
   c2a4c:	e0bffe17 	ldw	r2,-8(fp)
   c2a50:	10800b17 	ldw	r2,44(r2)
   c2a54:	108000a0 	cmpeqi	r2,r2,2
   c2a58:	10000a1e 	bne	r2,zero,c2a84 <alt_up_av_config_write_audio_cfg_register+0x64>
   c2a5c:	e0bffe17 	ldw	r2,-8(fp)
   c2a60:	10800b17 	ldw	r2,44(r2)
   c2a64:	108000e0 	cmpeqi	r2,r2,3
   c2a68:	1000061e 	bne	r2,zero,c2a84 <alt_up_av_config_write_audio_cfg_register+0x64>
   c2a6c:	e0bffe17 	ldw	r2,-8(fp)
   c2a70:	10800b17 	ldw	r2,44(r2)
   c2a74:	10800120 	cmpeqi	r2,r2,4
   c2a78:	1000021e 	bne	r2,zero,c2a84 <alt_up_av_config_write_audio_cfg_register+0x64>
		return -EINVAL;
   c2a7c:	00bffa84 	movi	r2,-22
   c2a80:	00000b06 	br	c2ab0 <alt_up_av_config_write_audio_cfg_register+0x90>

	// set the audio device to be configured in the Control register
	SELECTED_ON_BOARD_DEVICE device = AUDIO_DEVICE;
   c2a84:	e03fff15 	stw	zero,-4(fp)
	IOWR_ALT_UP_AV_CONFIG_CONTROL_DEVICE(av_config->base, device);
   c2a88:	e0bffe17 	ldw	r2,-8(fp)
   c2a8c:	10800a17 	ldw	r2,40(r2)
   c2a90:	10800084 	addi	r2,r2,2
   c2a94:	1007883a 	mov	r3,r2
   c2a98:	e0bfff17 	ldw	r2,-4(fp)
   c2a9c:	18800025 	stbio	r2,0(r3)

	return alt_up_av_config_write_data(av_config, addr, data);
   c2aa0:	e1bffc17 	ldw	r6,-16(fp)
   c2aa4:	e17ffd17 	ldw	r5,-12(fp)
   c2aa8:	e13ffe17 	ldw	r4,-8(fp)
   c2aac:	00c280c0 	call	c280c <alt_up_av_config_write_data>
}
   c2ab0:	e037883a 	mov	sp,fp
   c2ab4:	dfc00117 	ldw	ra,4(sp)
   c2ab8:	df000017 	ldw	fp,0(sp)
   c2abc:	dec00204 	addi	sp,sp,8
   c2ac0:	f800283a 	ret

000c2ac4 <alt_up_av_config_read_video_cfg_register>:

int alt_up_av_config_read_video_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 *data, SELECTED_ON_BOARD_DEVICE video_port)
{
   c2ac4:	defffa04 	addi	sp,sp,-24
   c2ac8:	dfc00515 	stw	ra,20(sp)
   c2acc:	df000415 	stw	fp,16(sp)
   c2ad0:	df000404 	addi	fp,sp,16
   c2ad4:	e13fff15 	stw	r4,-4(fp)
   c2ad8:	e17ffe15 	stw	r5,-8(fp)
   c2adc:	e1bffd15 	stw	r6,-12(fp)
   c2ae0:	e1fffc15 	stw	r7,-16(fp)
	// check the device is indeed audio configuration
	if (av_config->type != ON_BOARD_DE2_CONFIG && av_config->type != ON_BOARD_DE2_70_CONFIG && av_config->type != ON_BOARD_DE2_115_CONFIG)
   c2ae4:	e0bfff17 	ldw	r2,-4(fp)
   c2ae8:	10800b17 	ldw	r2,44(r2)
   c2aec:	108000a0 	cmpeqi	r2,r2,2
   c2af0:	10000a1e 	bne	r2,zero,c2b1c <alt_up_av_config_read_video_cfg_register+0x58>
   c2af4:	e0bfff17 	ldw	r2,-4(fp)
   c2af8:	10800b17 	ldw	r2,44(r2)
   c2afc:	108000e0 	cmpeqi	r2,r2,3
   c2b00:	1000061e 	bne	r2,zero,c2b1c <alt_up_av_config_read_video_cfg_register+0x58>
   c2b04:	e0bfff17 	ldw	r2,-4(fp)
   c2b08:	10800b17 	ldw	r2,44(r2)
   c2b0c:	10800120 	cmpeqi	r2,r2,4
   c2b10:	1000021e 	bne	r2,zero,c2b1c <alt_up_av_config_read_video_cfg_register+0x58>
		return -EINVAL;
   c2b14:	00bffa84 	movi	r2,-22
   c2b18:	00001f06 	br	c2b98 <alt_up_av_config_read_video_cfg_register+0xd4>

	if (av_config->type == ON_BOARD_DE2_CONFIG || av_config->type == ON_BOARD_DE2_115_CONFIG)
   c2b1c:	e0bfff17 	ldw	r2,-4(fp)
   c2b20:	10800b17 	ldw	r2,44(r2)
   c2b24:	108000a0 	cmpeqi	r2,r2,2
   c2b28:	1000041e 	bne	r2,zero,c2b3c <alt_up_av_config_read_video_cfg_register+0x78>
   c2b2c:	e0bfff17 	ldw	r2,-4(fp)
   c2b30:	10800b17 	ldw	r2,44(r2)
   c2b34:	10800118 	cmpnei	r2,r2,4
   c2b38:	1000051e 	bne	r2,zero,c2b50 <alt_up_av_config_read_video_cfg_register+0x8c>
	{
		if (video_port != FIRST_VIDEO_DEVICE)
   c2b3c:	e0bffc17 	ldw	r2,-16(fp)
   c2b40:	10800060 	cmpeqi	r2,r2,1
   c2b44:	10000a1e 	bne	r2,zero,c2b70 <alt_up_av_config_read_video_cfg_register+0xac>
			return -EINVAL;
   c2b48:	00bffa84 	movi	r2,-22
   c2b4c:	00001206 	br	c2b98 <alt_up_av_config_read_video_cfg_register+0xd4>
	} else {
		if ((video_port != FIRST_VIDEO_DEVICE) && (video_port != SECOND_VIDEO_DEVICE))
   c2b50:	e0bffc17 	ldw	r2,-16(fp)
   c2b54:	10800060 	cmpeqi	r2,r2,1
   c2b58:	1000051e 	bne	r2,zero,c2b70 <alt_up_av_config_read_video_cfg_register+0xac>
   c2b5c:	e0bffc17 	ldw	r2,-16(fp)
   c2b60:	108000a0 	cmpeqi	r2,r2,2
   c2b64:	1000021e 	bne	r2,zero,c2b70 <alt_up_av_config_read_video_cfg_register+0xac>
			return -EINVAL;
   c2b68:	00bffa84 	movi	r2,-22
   c2b6c:	00000a06 	br	c2b98 <alt_up_av_config_read_video_cfg_register+0xd4>
	}

	// set the video device to be configured in the Control register
	IOWR_ALT_UP_AV_CONFIG_CONTROL_DEVICE(av_config->base, video_port);
   c2b70:	e0bfff17 	ldw	r2,-4(fp)
   c2b74:	10800a17 	ldw	r2,40(r2)
   c2b78:	10800084 	addi	r2,r2,2
   c2b7c:	1007883a 	mov	r3,r2
   c2b80:	e0bffc17 	ldw	r2,-16(fp)
   c2b84:	18800025 	stbio	r2,0(r3)

	return alt_up_av_config_read_data(av_config, addr, data);
   c2b88:	e1bffd17 	ldw	r6,-12(fp)
   c2b8c:	e17ffe17 	ldw	r5,-8(fp)
   c2b90:	e13fff17 	ldw	r4,-4(fp)
   c2b94:	00c28700 	call	c2870 <alt_up_av_config_read_data>
}
   c2b98:	e037883a 	mov	sp,fp
   c2b9c:	dfc00117 	ldw	ra,4(sp)
   c2ba0:	df000017 	ldw	fp,0(sp)
   c2ba4:	dec00204 	addi	sp,sp,8
   c2ba8:	f800283a 	ret

000c2bac <alt_up_av_config_write_video_cfg_register>:

int alt_up_av_config_write_video_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data, SELECTED_ON_BOARD_DEVICE video_port)
{
   c2bac:	defffa04 	addi	sp,sp,-24
   c2bb0:	dfc00515 	stw	ra,20(sp)
   c2bb4:	df000415 	stw	fp,16(sp)
   c2bb8:	df000404 	addi	fp,sp,16
   c2bbc:	e13fff15 	stw	r4,-4(fp)
   c2bc0:	e17ffe15 	stw	r5,-8(fp)
   c2bc4:	e1bffd15 	stw	r6,-12(fp)
   c2bc8:	e1fffc15 	stw	r7,-16(fp)
	// check the device is indeed audio configuration
	if (av_config->type != ON_BOARD_DE2_CONFIG && av_config->type != ON_BOARD_DE2_70_CONFIG && av_config->type != ON_BOARD_DE2_115_CONFIG)
   c2bcc:	e0bfff17 	ldw	r2,-4(fp)
   c2bd0:	10800b17 	ldw	r2,44(r2)
   c2bd4:	108000a0 	cmpeqi	r2,r2,2
   c2bd8:	10000a1e 	bne	r2,zero,c2c04 <alt_up_av_config_write_video_cfg_register+0x58>
   c2bdc:	e0bfff17 	ldw	r2,-4(fp)
   c2be0:	10800b17 	ldw	r2,44(r2)
   c2be4:	108000e0 	cmpeqi	r2,r2,3
   c2be8:	1000061e 	bne	r2,zero,c2c04 <alt_up_av_config_write_video_cfg_register+0x58>
   c2bec:	e0bfff17 	ldw	r2,-4(fp)
   c2bf0:	10800b17 	ldw	r2,44(r2)
   c2bf4:	10800120 	cmpeqi	r2,r2,4
   c2bf8:	1000021e 	bne	r2,zero,c2c04 <alt_up_av_config_write_video_cfg_register+0x58>
		return -EINVAL;
   c2bfc:	00bffa84 	movi	r2,-22
   c2c00:	00001f06 	br	c2c80 <alt_up_av_config_write_video_cfg_register+0xd4>

	if (av_config->type == ON_BOARD_DE2_CONFIG || av_config->type == ON_BOARD_DE2_115_CONFIG)
   c2c04:	e0bfff17 	ldw	r2,-4(fp)
   c2c08:	10800b17 	ldw	r2,44(r2)
   c2c0c:	108000a0 	cmpeqi	r2,r2,2
   c2c10:	1000041e 	bne	r2,zero,c2c24 <alt_up_av_config_write_video_cfg_register+0x78>
   c2c14:	e0bfff17 	ldw	r2,-4(fp)
   c2c18:	10800b17 	ldw	r2,44(r2)
   c2c1c:	10800118 	cmpnei	r2,r2,4
   c2c20:	1000051e 	bne	r2,zero,c2c38 <alt_up_av_config_write_video_cfg_register+0x8c>
	{
		if (video_port != FIRST_VIDEO_DEVICE)
   c2c24:	e0bffc17 	ldw	r2,-16(fp)
   c2c28:	10800060 	cmpeqi	r2,r2,1
   c2c2c:	10000a1e 	bne	r2,zero,c2c58 <alt_up_av_config_write_video_cfg_register+0xac>
			return -EINVAL;
   c2c30:	00bffa84 	movi	r2,-22
   c2c34:	00001206 	br	c2c80 <alt_up_av_config_write_video_cfg_register+0xd4>
	} else {
		if ((video_port != FIRST_VIDEO_DEVICE) && (video_port != SECOND_VIDEO_DEVICE))
   c2c38:	e0bffc17 	ldw	r2,-16(fp)
   c2c3c:	10800060 	cmpeqi	r2,r2,1
   c2c40:	1000051e 	bne	r2,zero,c2c58 <alt_up_av_config_write_video_cfg_register+0xac>
   c2c44:	e0bffc17 	ldw	r2,-16(fp)
   c2c48:	108000a0 	cmpeqi	r2,r2,2
   c2c4c:	1000021e 	bne	r2,zero,c2c58 <alt_up_av_config_write_video_cfg_register+0xac>
			return -EINVAL;
   c2c50:	00bffa84 	movi	r2,-22
   c2c54:	00000a06 	br	c2c80 <alt_up_av_config_write_video_cfg_register+0xd4>
	}

	// set the video device to be configured in the Control register
	IOWR_ALT_UP_AV_CONFIG_CONTROL_DEVICE(av_config->base, video_port);
   c2c58:	e0bfff17 	ldw	r2,-4(fp)
   c2c5c:	10800a17 	ldw	r2,40(r2)
   c2c60:	10800084 	addi	r2,r2,2
   c2c64:	1007883a 	mov	r3,r2
   c2c68:	e0bffc17 	ldw	r2,-16(fp)
   c2c6c:	18800025 	stbio	r2,0(r3)

	return alt_up_av_config_write_data(av_config, addr, data);
   c2c70:	e1bffd17 	ldw	r6,-12(fp)
   c2c74:	e17ffe17 	ldw	r5,-8(fp)
   c2c78:	e13fff17 	ldw	r4,-4(fp)
   c2c7c:	00c280c0 	call	c280c <alt_up_av_config_write_data>
}
   c2c80:	e037883a 	mov	sp,fp
   c2c84:	dfc00117 	ldw	ra,4(sp)
   c2c88:	df000017 	ldw	fp,0(sp)
   c2c8c:	dec00204 	addi	sp,sp,8
   c2c90:	f800283a 	ret

000c2c94 <alt_up_av_config_read_DC2_cfg_register>:

int alt_up_av_config_read_DC2_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 *data)
{
   c2c94:	defffb04 	addi	sp,sp,-20
   c2c98:	dfc00415 	stw	ra,16(sp)
   c2c9c:	df000315 	stw	fp,12(sp)
   c2ca0:	df000304 	addi	fp,sp,12
   c2ca4:	e13fff15 	stw	r4,-4(fp)
   c2ca8:	e17ffe15 	stw	r5,-8(fp)
   c2cac:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_DC2_CONFIG)
   c2cb0:	e0bfff17 	ldw	r2,-4(fp)
   c2cb4:	10800b17 	ldw	r2,44(r2)
   c2cb8:	10800220 	cmpeqi	r2,r2,8
   c2cbc:	1000021e 	bne	r2,zero,c2cc8 <alt_up_av_config_read_DC2_cfg_register+0x34>
		return -EINVAL;
   c2cc0:	00bffa84 	movi	r2,-22
   c2cc4:	00000406 	br	c2cd8 <alt_up_av_config_read_DC2_cfg_register+0x44>

	return alt_up_av_config_read_data(av_config, addr, data);
   c2cc8:	e1bffd17 	ldw	r6,-12(fp)
   c2ccc:	e17ffe17 	ldw	r5,-8(fp)
   c2cd0:	e13fff17 	ldw	r4,-4(fp)
   c2cd4:	00c28700 	call	c2870 <alt_up_av_config_read_data>
}
   c2cd8:	e037883a 	mov	sp,fp
   c2cdc:	dfc00117 	ldw	ra,4(sp)
   c2ce0:	df000017 	ldw	fp,0(sp)
   c2ce4:	dec00204 	addi	sp,sp,8
   c2ce8:	f800283a 	ret

000c2cec <alt_up_av_config_write_DC2_cfg_register>:

int alt_up_av_config_write_DC2_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data)
{
   c2cec:	defffb04 	addi	sp,sp,-20
   c2cf0:	dfc00415 	stw	ra,16(sp)
   c2cf4:	df000315 	stw	fp,12(sp)
   c2cf8:	df000304 	addi	fp,sp,12
   c2cfc:	e13fff15 	stw	r4,-4(fp)
   c2d00:	e17ffe15 	stw	r5,-8(fp)
   c2d04:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_DC2_CONFIG)
   c2d08:	e0bfff17 	ldw	r2,-4(fp)
   c2d0c:	10800b17 	ldw	r2,44(r2)
   c2d10:	10800220 	cmpeqi	r2,r2,8
   c2d14:	1000021e 	bne	r2,zero,c2d20 <alt_up_av_config_write_DC2_cfg_register+0x34>
		return -EINVAL;
   c2d18:	00bffa84 	movi	r2,-22
   c2d1c:	00000406 	br	c2d30 <alt_up_av_config_write_DC2_cfg_register+0x44>

	return alt_up_av_config_write_data(av_config, addr, data);
   c2d20:	e1bffd17 	ldw	r6,-12(fp)
   c2d24:	e17ffe17 	ldw	r5,-8(fp)
   c2d28:	e13fff17 	ldw	r4,-4(fp)
   c2d2c:	00c280c0 	call	c280c <alt_up_av_config_write_data>
}
   c2d30:	e037883a 	mov	sp,fp
   c2d34:	dfc00117 	ldw	ra,4(sp)
   c2d38:	df000017 	ldw	fp,0(sp)
   c2d3c:	dec00204 	addi	sp,sp,8
   c2d40:	f800283a 	ret

000c2d44 <alt_up_av_config_read_D5M_cfg_register>:

int alt_up_av_config_read_D5M_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 *data)
{
   c2d44:	defffb04 	addi	sp,sp,-20
   c2d48:	dfc00415 	stw	ra,16(sp)
   c2d4c:	df000315 	stw	fp,12(sp)
   c2d50:	df000304 	addi	fp,sp,12
   c2d54:	e13fff15 	stw	r4,-4(fp)
   c2d58:	e17ffe15 	stw	r5,-8(fp)
   c2d5c:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_D5M_CONFIG)
   c2d60:	e0bfff17 	ldw	r2,-4(fp)
   c2d64:	10800b17 	ldw	r2,44(r2)
   c2d68:	10800260 	cmpeqi	r2,r2,9
   c2d6c:	1000021e 	bne	r2,zero,c2d78 <alt_up_av_config_read_D5M_cfg_register+0x34>
		return -EINVAL;
   c2d70:	00bffa84 	movi	r2,-22
   c2d74:	00000406 	br	c2d88 <alt_up_av_config_read_D5M_cfg_register+0x44>
	
	return alt_up_av_config_read_data(av_config, addr, data);
   c2d78:	e1bffd17 	ldw	r6,-12(fp)
   c2d7c:	e17ffe17 	ldw	r5,-8(fp)
   c2d80:	e13fff17 	ldw	r4,-4(fp)
   c2d84:	00c28700 	call	c2870 <alt_up_av_config_read_data>
}
   c2d88:	e037883a 	mov	sp,fp
   c2d8c:	dfc00117 	ldw	ra,4(sp)
   c2d90:	df000017 	ldw	fp,0(sp)
   c2d94:	dec00204 	addi	sp,sp,8
   c2d98:	f800283a 	ret

000c2d9c <alt_up_av_config_write_D5M_cfg_register>:

int alt_up_av_config_write_D5M_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data)
{
   c2d9c:	defffb04 	addi	sp,sp,-20
   c2da0:	dfc00415 	stw	ra,16(sp)
   c2da4:	df000315 	stw	fp,12(sp)
   c2da8:	df000304 	addi	fp,sp,12
   c2dac:	e13fff15 	stw	r4,-4(fp)
   c2db0:	e17ffe15 	stw	r5,-8(fp)
   c2db4:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_D5M_CONFIG)
   c2db8:	e0bfff17 	ldw	r2,-4(fp)
   c2dbc:	10800b17 	ldw	r2,44(r2)
   c2dc0:	10800260 	cmpeqi	r2,r2,9
   c2dc4:	1000021e 	bne	r2,zero,c2dd0 <alt_up_av_config_write_D5M_cfg_register+0x34>
		return -EINVAL;
   c2dc8:	00bffa84 	movi	r2,-22
   c2dcc:	00000406 	br	c2de0 <alt_up_av_config_write_D5M_cfg_register+0x44>
	
	return alt_up_av_config_write_data(av_config, addr, data);
   c2dd0:	e1bffd17 	ldw	r6,-12(fp)
   c2dd4:	e17ffe17 	ldw	r5,-8(fp)
   c2dd8:	e13fff17 	ldw	r4,-4(fp)
   c2ddc:	00c280c0 	call	c280c <alt_up_av_config_write_data>
}
   c2de0:	e037883a 	mov	sp,fp
   c2de4:	dfc00117 	ldw	ra,4(sp)
   c2de8:	df000017 	ldw	fp,0(sp)
   c2dec:	dec00204 	addi	sp,sp,8
   c2df0:	f800283a 	ret

000c2df4 <alt_up_av_config_read_LTM_cfg_register>:

int alt_up_av_config_read_LTM_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 *data)
{
   c2df4:	defffb04 	addi	sp,sp,-20
   c2df8:	dfc00415 	stw	ra,16(sp)
   c2dfc:	df000315 	stw	fp,12(sp)
   c2e00:	df000304 	addi	fp,sp,12
   c2e04:	e13fff15 	stw	r4,-4(fp)
   c2e08:	e17ffe15 	stw	r5,-8(fp)
   c2e0c:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_LTM_CONFIG)
   c2e10:	e0bfff17 	ldw	r2,-4(fp)
   c2e14:	10800b17 	ldw	r2,44(r2)
   c2e18:	108002a0 	cmpeqi	r2,r2,10
   c2e1c:	1000021e 	bne	r2,zero,c2e28 <alt_up_av_config_read_LTM_cfg_register+0x34>
		return -EINVAL;
   c2e20:	00bffa84 	movi	r2,-22
   c2e24:	00000406 	br	c2e38 <alt_up_av_config_read_LTM_cfg_register+0x44>

	return alt_up_av_config_read_data(av_config, addr, data);
   c2e28:	e1bffd17 	ldw	r6,-12(fp)
   c2e2c:	e17ffe17 	ldw	r5,-8(fp)
   c2e30:	e13fff17 	ldw	r4,-4(fp)
   c2e34:	00c28700 	call	c2870 <alt_up_av_config_read_data>
}
   c2e38:	e037883a 	mov	sp,fp
   c2e3c:	dfc00117 	ldw	ra,4(sp)
   c2e40:	df000017 	ldw	fp,0(sp)
   c2e44:	dec00204 	addi	sp,sp,8
   c2e48:	f800283a 	ret

000c2e4c <alt_up_av_config_write_LTM_cfg_register>:

int alt_up_av_config_write_LTM_cfg_register(alt_up_av_config_dev *av_config, alt_u32 addr, alt_u32 data)
{
   c2e4c:	defffb04 	addi	sp,sp,-20
   c2e50:	dfc00415 	stw	ra,16(sp)
   c2e54:	df000315 	stw	fp,12(sp)
   c2e58:	df000304 	addi	fp,sp,12
   c2e5c:	e13fff15 	stw	r4,-4(fp)
   c2e60:	e17ffe15 	stw	r5,-8(fp)
   c2e64:	e1bffd15 	stw	r6,-12(fp)
	if (av_config->type != TRDB_LTM_CONFIG)
   c2e68:	e0bfff17 	ldw	r2,-4(fp)
   c2e6c:	10800b17 	ldw	r2,44(r2)
   c2e70:	108002a0 	cmpeqi	r2,r2,10
   c2e74:	1000021e 	bne	r2,zero,c2e80 <alt_up_av_config_write_LTM_cfg_register+0x34>
		return -EINVAL;
   c2e78:	00bffa84 	movi	r2,-22
   c2e7c:	00000406 	br	c2e90 <alt_up_av_config_write_LTM_cfg_register+0x44>

	return alt_up_av_config_write_data(av_config, addr, data);
   c2e80:	e1bffd17 	ldw	r6,-12(fp)
   c2e84:	e17ffe17 	ldw	r5,-8(fp)
   c2e88:	e13fff17 	ldw	r4,-4(fp)
   c2e8c:	00c280c0 	call	c280c <alt_up_av_config_write_data>
}
   c2e90:	e037883a 	mov	sp,fp
   c2e94:	dfc00117 	ldw	ra,4(sp)
   c2e98:	df000017 	ldw	fp,0(sp)
   c2e9c:	dec00204 	addi	sp,sp,8
   c2ea0:	f800283a 	ret

000c2ea4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   c2ea4:	defffa04 	addi	sp,sp,-24
   c2ea8:	dfc00515 	stw	ra,20(sp)
   c2eac:	df000415 	stw	fp,16(sp)
   c2eb0:	df000404 	addi	fp,sp,16
   c2eb4:	e13ffc15 	stw	r4,-16(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
   c2eb8:	00800244 	movi	r2,9
   c2ebc:	e0bffe15 	stw	r2,-8(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   c2ec0:	014003f4 	movhi	r5,15
   c2ec4:	29509004 	addi	r5,r5,16960
   c2ec8:	e13ffe17 	ldw	r4,-8(fp)
   c2ecc:	00c0e100 	call	c0e10 <__mulsi3>
   c2ed0:	100b883a 	mov	r5,r2
   c2ed4:	0100bef4 	movhi	r4,763
   c2ed8:	213c2004 	addi	r4,r4,-3968
   c2edc:	00c0d500 	call	c0d50 <__udivsi3>
  big_loops = us / (INT_MAX/
   c2ee0:	100b883a 	mov	r5,r2
   c2ee4:	01200034 	movhi	r4,32768
   c2ee8:	213fffc4 	addi	r4,r4,-1
   c2eec:	00c0d500 	call	c0d50 <__udivsi3>
   c2ef0:	100b883a 	mov	r5,r2
   c2ef4:	e13ffc17 	ldw	r4,-16(fp)
   c2ef8:	00c0d500 	call	c0d50 <__udivsi3>
   c2efc:	e0bffd15 	stw	r2,-12(fp)

  if (big_loops)
   c2f00:	e0bffd17 	ldw	r2,-12(fp)
   c2f04:	10002a26 	beq	r2,zero,c2fb0 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
   c2f08:	e03fff15 	stw	zero,-4(fp)
   c2f0c:	00001706 	br	c2f6c <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   c2f10:	00a00034 	movhi	r2,32768
   c2f14:	10bfffc4 	addi	r2,r2,-1
   c2f18:	10bfffc4 	addi	r2,r2,-1
   c2f1c:	103ffe1e 	bne	r2,zero,c2f18 <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   c2f20:	014003f4 	movhi	r5,15
   c2f24:	29509004 	addi	r5,r5,16960
   c2f28:	e13ffe17 	ldw	r4,-8(fp)
   c2f2c:	00c0e100 	call	c0e10 <__mulsi3>
      us -= (INT_MAX/(ALT_CPU_FREQ/
   c2f30:	100b883a 	mov	r5,r2
   c2f34:	0100bef4 	movhi	r4,763
   c2f38:	213c2004 	addi	r4,r4,-3968
   c2f3c:	00c0d500 	call	c0d50 <__udivsi3>
   c2f40:	100b883a 	mov	r5,r2
   c2f44:	01200034 	movhi	r4,32768
   c2f48:	213fffc4 	addi	r4,r4,-1
   c2f4c:	00c0d500 	call	c0d50 <__udivsi3>
   c2f50:	1007883a 	mov	r3,r2
   c2f54:	e0bffc17 	ldw	r2,-16(fp)
   c2f58:	10c5c83a 	sub	r2,r2,r3
   c2f5c:	e0bffc15 	stw	r2,-16(fp)
    for(i=0;i<big_loops;i++)
   c2f60:	e0bfff17 	ldw	r2,-4(fp)
   c2f64:	10800044 	addi	r2,r2,1
   c2f68:	e0bfff15 	stw	r2,-4(fp)
   c2f6c:	e0ffff17 	ldw	r3,-4(fp)
   c2f70:	e0bffd17 	ldw	r2,-12(fp)
   c2f74:	18bfe616 	blt	r3,r2,c2f10 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   c2f78:	014003f4 	movhi	r5,15
   c2f7c:	29509004 	addi	r5,r5,16960
   c2f80:	e13ffe17 	ldw	r4,-8(fp)
   c2f84:	00c0e100 	call	c0e10 <__mulsi3>
   c2f88:	100b883a 	mov	r5,r2
   c2f8c:	0100bef4 	movhi	r4,763
   c2f90:	213c2004 	addi	r4,r4,-3968
   c2f94:	00c0d500 	call	c0d50 <__udivsi3>
   c2f98:	e17ffc17 	ldw	r5,-16(fp)
   c2f9c:	1009883a 	mov	r4,r2
   c2fa0:	00c0e100 	call	c0e10 <__mulsi3>
    __asm__ volatile (
   c2fa4:	10bfffc4 	addi	r2,r2,-1
   c2fa8:	103ffe1e 	bne	r2,zero,c2fa4 <alt_busy_sleep+0x100>
   c2fac:	00000d06 	br	c2fe4 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   c2fb0:	014003f4 	movhi	r5,15
   c2fb4:	29509004 	addi	r5,r5,16960
   c2fb8:	e13ffe17 	ldw	r4,-8(fp)
   c2fbc:	00c0e100 	call	c0e10 <__mulsi3>
   c2fc0:	100b883a 	mov	r5,r2
   c2fc4:	0100bef4 	movhi	r4,763
   c2fc8:	213c2004 	addi	r4,r4,-3968
   c2fcc:	00c0d500 	call	c0d50 <__udivsi3>
   c2fd0:	e17ffc17 	ldw	r5,-16(fp)
   c2fd4:	1009883a 	mov	r4,r2
   c2fd8:	00c0e100 	call	c0e10 <__mulsi3>
    __asm__ volatile (
   c2fdc:	10bfffc4 	addi	r2,r2,-1
   c2fe0:	00bffe16 	blt	zero,r2,c2fdc <alt_busy_sleep+0x138>
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   c2fe4:	0005883a 	mov	r2,zero
}
   c2fe8:	e037883a 	mov	sp,fp
   c2fec:	dfc00117 	ldw	ra,4(sp)
   c2ff0:	df000017 	ldw	fp,0(sp)
   c2ff4:	dec00204 	addi	sp,sp,8
   c2ff8:	f800283a 	ret

000c2ffc <alt_get_errno>:

  if (fd)
  {
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
   c2ffc:	defffe04 	addi	sp,sp,-8
   c3000:	dfc00115 	stw	ra,4(sp)
   c3004:	df000015 	stw	fp,0(sp)
   c3008:	d839883a 	mov	fp,sp
     */
   c300c:	d0a00917 	ldw	r2,-32732(gp)
   c3010:	10000326 	beq	r2,zero,c3020 <alt_get_errno+0x24>
   c3014:	d0a00917 	ldw	r2,-32732(gp)
   c3018:	103ee83a 	callr	r2
   c301c:	00000106 	br	c3024 <alt_get_errno+0x28>
   c3020:	d0a0c104 	addi	r2,gp,-31996

   c3024:	e037883a 	mov	sp,fp
   c3028:	dfc00117 	ldw	ra,4(sp)
   c302c:	df000017 	ldw	fp,0(sp)
   c3030:	dec00204 	addi	sp,sp,8
   c3034:	f800283a 	ret

000c3038 <close>:
{
   c3038:	defffb04 	addi	sp,sp,-20
   c303c:	dfc00415 	stw	ra,16(sp)
   c3040:	df000315 	stw	fp,12(sp)
   c3044:	df000304 	addi	fp,sp,12
   c3048:	e13ffd15 	stw	r4,-12(fp)
  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   c304c:	e0bffd17 	ldw	r2,-12(fp)
   c3050:	10000916 	blt	r2,zero,c3078 <close+0x40>
   c3054:	e0fffd17 	ldw	r3,-12(fp)
   c3058:	1805883a 	mov	r2,r3
   c305c:	1085883a 	add	r2,r2,r2
   c3060:	10c5883a 	add	r2,r2,r3
   c3064:	100490ba 	slli	r2,r2,2
   c3068:	00c00334 	movhi	r3,12
   c306c:	18d0af04 	addi	r3,r3,17084
   c3070:	10c5883a 	add	r2,r2,r3
   c3074:	00000106 	br	c307c <close+0x44>
   c3078:	0005883a 	mov	r2,zero
   c307c:	e0bfff15 	stw	r2,-4(fp)
  if (fd)
   c3080:	e0bfff17 	ldw	r2,-4(fp)
   c3084:	10001926 	beq	r2,zero,c30ec <close+0xb4>
    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   c3088:	e0bfff17 	ldw	r2,-4(fp)
   c308c:	10800017 	ldw	r2,0(r2)
   c3090:	10800417 	ldw	r2,16(r2)
   c3094:	10000626 	beq	r2,zero,c30b0 <close+0x78>
   c3098:	e0bfff17 	ldw	r2,-4(fp)
   c309c:	10800017 	ldw	r2,0(r2)
   c30a0:	10800417 	ldw	r2,16(r2)
   c30a4:	e13fff17 	ldw	r4,-4(fp)
   c30a8:	103ee83a 	callr	r2
   c30ac:	00000106 	br	c30b4 <close+0x7c>
   c30b0:	0005883a 	mov	r2,zero
   c30b4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   c30b8:	e13ffd17 	ldw	r4,-12(fp)
   c30bc:	00c39040 	call	c3904 <alt_release_fd>
    if (rval < 0)
   c30c0:	e0bffe17 	ldw	r2,-8(fp)
   c30c4:	1000070e 	bge	r2,zero,c30e4 <close+0xac>
    {
      ALT_ERRNO = -rval;
   c30c8:	00c2ffc0 	call	c2ffc <alt_get_errno>
   c30cc:	1007883a 	mov	r3,r2
   c30d0:	e0bffe17 	ldw	r2,-8(fp)
   c30d4:	0085c83a 	sub	r2,zero,r2
   c30d8:	18800015 	stw	r2,0(r3)
      return -1;
   c30dc:	00bfffc4 	movi	r2,-1
   c30e0:	00000706 	br	c3100 <close+0xc8>
    }
    return 0;
   c30e4:	0005883a 	mov	r2,zero
   c30e8:	00000506 	br	c3100 <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   c30ec:	00c2ffc0 	call	c2ffc <alt_get_errno>
   c30f0:	1007883a 	mov	r3,r2
   c30f4:	00801444 	movi	r2,81
   c30f8:	18800015 	stw	r2,0(r3)
    return -1;
   c30fc:	00bfffc4 	movi	r2,-1
  }
}
   c3100:	e037883a 	mov	sp,fp
   c3104:	dfc00117 	ldw	ra,4(sp)
   c3108:	df000017 	ldw	fp,0(sp)
   c310c:	dec00204 	addi	sp,sp,8
   c3110:	f800283a 	ret

000c3114 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   c3114:	deffff04 	addi	sp,sp,-4
   c3118:	df000015 	stw	fp,0(sp)
   c311c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   c3120:	0001883a 	nop
   c3124:	e037883a 	mov	sp,fp
   c3128:	df000017 	ldw	fp,0(sp)
   c312c:	dec00104 	addi	sp,sp,4
   c3130:	f800283a 	ret

000c3134 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   c3134:	defffc04 	addi	sp,sp,-16
   c3138:	df000315 	stw	fp,12(sp)
   c313c:	df000304 	addi	fp,sp,12
   c3140:	e13fff15 	stw	r4,-4(fp)
   c3144:	e17ffe15 	stw	r5,-8(fp)
   c3148:	e1bffd15 	stw	r6,-12(fp)
  return len;
   c314c:	e0bffd17 	ldw	r2,-12(fp)
}
   c3150:	e037883a 	mov	sp,fp
   c3154:	df000017 	ldw	fp,0(sp)
   c3158:	dec00104 	addi	sp,sp,4
   c315c:	f800283a 	ret

000c3160 <alt_get_errno>:
   c3160:	defffe04 	addi	sp,sp,-8
   c3164:	dfc00115 	stw	ra,4(sp)
   c3168:	df000015 	stw	fp,0(sp)
   c316c:	d839883a 	mov	fp,sp
   c3170:	d0a00917 	ldw	r2,-32732(gp)
   c3174:	10000326 	beq	r2,zero,c3184 <alt_get_errno+0x24>
   c3178:	d0a00917 	ldw	r2,-32732(gp)
   c317c:	103ee83a 	callr	r2
   c3180:	00000106 	br	c3188 <alt_get_errno+0x28>
   c3184:	d0a0c104 	addi	r2,gp,-31996
   c3188:	e037883a 	mov	sp,fp
   c318c:	dfc00117 	ldw	ra,4(sp)
   c3190:	df000017 	ldw	fp,0(sp)
   c3194:	dec00204 	addi	sp,sp,8
   c3198:	f800283a 	ret

000c319c <alt_dev_llist_insert>:
{
   c319c:	defffa04 	addi	sp,sp,-24
   c31a0:	dfc00515 	stw	ra,20(sp)
   c31a4:	df000415 	stw	fp,16(sp)
   c31a8:	df000404 	addi	fp,sp,16
   c31ac:	e13ffd15 	stw	r4,-12(fp)
   c31b0:	e17ffc15 	stw	r5,-16(fp)
  if (!dev || !dev->name)
   c31b4:	e0bffd17 	ldw	r2,-12(fp)
   c31b8:	10000326 	beq	r2,zero,c31c8 <alt_dev_llist_insert+0x2c>
   c31bc:	e0bffd17 	ldw	r2,-12(fp)
   c31c0:	10800217 	ldw	r2,8(r2)
   c31c4:	1000061e 	bne	r2,zero,c31e0 <alt_dev_llist_insert+0x44>
    ALT_ERRNO = EINVAL;
   c31c8:	00c31600 	call	c3160 <alt_get_errno>
   c31cc:	1007883a 	mov	r3,r2
   c31d0:	00800584 	movi	r2,22
   c31d4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
   c31d8:	00bffa84 	movi	r2,-22
   c31dc:	00001406 	br	c3230 <alt_dev_llist_insert+0x94>
  alt_llist_insert(list, &dev->llist);
   c31e0:	e0bffd17 	ldw	r2,-12(fp)
   c31e4:	e0fffc17 	ldw	r3,-16(fp)
   c31e8:	e0ffff15 	stw	r3,-4(fp)
   c31ec:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
   c31f0:	e0bffe17 	ldw	r2,-8(fp)
   c31f4:	e0ffff17 	ldw	r3,-4(fp)
   c31f8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   c31fc:	e0bfff17 	ldw	r2,-4(fp)
   c3200:	10c00017 	ldw	r3,0(r2)
   c3204:	e0bffe17 	ldw	r2,-8(fp)
   c3208:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
   c320c:	e0bfff17 	ldw	r2,-4(fp)
   c3210:	10800017 	ldw	r2,0(r2)
   c3214:	e0fffe17 	ldw	r3,-8(fp)
   c3218:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   c321c:	e0bfff17 	ldw	r2,-4(fp)
   c3220:	e0fffe17 	ldw	r3,-8(fp)
   c3224:	10c00015 	stw	r3,0(r2)
}
   c3228:	0001883a 	nop
  return 0;  
   c322c:	0005883a 	mov	r2,zero
}
   c3230:	e037883a 	mov	sp,fp
   c3234:	dfc00117 	ldw	ra,4(sp)
   c3238:	df000017 	ldw	fp,0(sp)
   c323c:	dec00204 	addi	sp,sp,8
   c3240:	f800283a 	ret

000c3244 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
   c3244:	defffd04 	addi	sp,sp,-12
   c3248:	dfc00215 	stw	ra,8(sp)
   c324c:	df000115 	stw	fp,4(sp)
   c3250:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   c3254:	00800334 	movhi	r2,12
   c3258:	108faf04 	addi	r2,r2,16060
   c325c:	e0bfff15 	stw	r2,-4(fp)
   c3260:	00000606 	br	c327c <_do_ctors+0x38>
        (*ctor) (); 
   c3264:	e0bfff17 	ldw	r2,-4(fp)
   c3268:	10800017 	ldw	r2,0(r2)
   c326c:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   c3270:	e0bfff17 	ldw	r2,-4(fp)
   c3274:	10bfff04 	addi	r2,r2,-4
   c3278:	e0bfff15 	stw	r2,-4(fp)
   c327c:	e0ffff17 	ldw	r3,-4(fp)
   c3280:	00800334 	movhi	r2,12
   c3284:	108fb004 	addi	r2,r2,16064
   c3288:	18bff62e 	bgeu	r3,r2,c3264 <_do_ctors+0x20>
}
   c328c:	0001883a 	nop
   c3290:	0001883a 	nop
   c3294:	e037883a 	mov	sp,fp
   c3298:	dfc00117 	ldw	ra,4(sp)
   c329c:	df000017 	ldw	fp,0(sp)
   c32a0:	dec00204 	addi	sp,sp,8
   c32a4:	f800283a 	ret

000c32a8 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
   c32a8:	defffd04 	addi	sp,sp,-12
   c32ac:	dfc00215 	stw	ra,8(sp)
   c32b0:	df000115 	stw	fp,4(sp)
   c32b4:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   c32b8:	00800334 	movhi	r2,12
   c32bc:	108faf04 	addi	r2,r2,16060
   c32c0:	e0bfff15 	stw	r2,-4(fp)
   c32c4:	00000606 	br	c32e0 <_do_dtors+0x38>
        (*dtor) (); 
   c32c8:	e0bfff17 	ldw	r2,-4(fp)
   c32cc:	10800017 	ldw	r2,0(r2)
   c32d0:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   c32d4:	e0bfff17 	ldw	r2,-4(fp)
   c32d8:	10bfff04 	addi	r2,r2,-4
   c32dc:	e0bfff15 	stw	r2,-4(fp)
   c32e0:	e0ffff17 	ldw	r3,-4(fp)
   c32e4:	00800334 	movhi	r2,12
   c32e8:	108fb004 	addi	r2,r2,16064
   c32ec:	18bff62e 	bgeu	r3,r2,c32c8 <_do_dtors+0x20>
}
   c32f0:	0001883a 	nop
   c32f4:	0001883a 	nop
   c32f8:	e037883a 	mov	sp,fp
   c32fc:	dfc00117 	ldw	ra,4(sp)
   c3300:	df000017 	ldw	fp,0(sp)
   c3304:	dec00204 	addi	sp,sp,8
   c3308:	f800283a 	ret

000c330c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   c330c:	defffa04 	addi	sp,sp,-24
   c3310:	dfc00515 	stw	ra,20(sp)
   c3314:	df000415 	stw	fp,16(sp)
   c3318:	df000404 	addi	fp,sp,16
   c331c:	e13ffd15 	stw	r4,-12(fp)
   c3320:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
   c3324:	e0bffc17 	ldw	r2,-16(fp)
   c3328:	10800017 	ldw	r2,0(r2)
   c332c:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   c3330:	e13ffd17 	ldw	r4,-12(fp)
   c3334:	00c0f4c0 	call	c0f4c <strlen>
   c3338:	10800044 	addi	r2,r2,1
   c333c:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   c3340:	00000d06 	br	c3378 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   c3344:	e0bfff17 	ldw	r2,-4(fp)
   c3348:	10800217 	ldw	r2,8(r2)
   c334c:	e0fffe17 	ldw	r3,-8(fp)
   c3350:	180d883a 	mov	r6,r3
   c3354:	e17ffd17 	ldw	r5,-12(fp)
   c3358:	1009883a 	mov	r4,r2
   c335c:	00c3c000 	call	c3c00 <memcmp>
   c3360:	1000021e 	bne	r2,zero,c336c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   c3364:	e0bfff17 	ldw	r2,-4(fp)
   c3368:	00000706 	br	c3388 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   c336c:	e0bfff17 	ldw	r2,-4(fp)
   c3370:	10800017 	ldw	r2,0(r2)
   c3374:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
   c3378:	e0ffff17 	ldw	r3,-4(fp)
   c337c:	e0bffc17 	ldw	r2,-16(fp)
   c3380:	18bff01e 	bne	r3,r2,c3344 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
   c3384:	0005883a 	mov	r2,zero
}
   c3388:	e037883a 	mov	sp,fp
   c338c:	dfc00117 	ldw	ra,4(sp)
   c3390:	df000017 	ldw	fp,0(sp)
   c3394:	dec00204 	addi	sp,sp,8
   c3398:	f800283a 	ret

000c339c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   c339c:	deffff04 	addi	sp,sp,-4
   c33a0:	df000015 	stw	fp,0(sp)
   c33a4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   c33a8:	0001883a 	nop
   c33ac:	e037883a 	mov	sp,fp
   c33b0:	df000017 	ldw	fp,0(sp)
   c33b4:	dec00104 	addi	sp,sp,4
   c33b8:	f800283a 	ret

000c33bc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   c33bc:	defff904 	addi	sp,sp,-28
   c33c0:	dfc00615 	stw	ra,24(sp)
   c33c4:	df000515 	stw	fp,20(sp)
   c33c8:	df000504 	addi	fp,sp,20
   c33cc:	e13ffe15 	stw	r4,-8(fp)
   c33d0:	e17ffd15 	stw	r5,-12(fp)
   c33d4:	e1bffc15 	stw	r6,-16(fp)
   c33d8:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
   c33dc:	e1bffb17 	ldw	r6,-20(fp)
   c33e0:	e17ffc17 	ldw	r5,-16(fp)
   c33e4:	e13ffd17 	ldw	r4,-12(fp)
   c33e8:	00c37a40 	call	c37a4 <open>
   c33ec:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
   c33f0:	e0bfff17 	ldw	r2,-4(fp)
   c33f4:	10002016 	blt	r2,zero,c3478 <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
   c33f8:	e0ffff17 	ldw	r3,-4(fp)
   c33fc:	1805883a 	mov	r2,r3
   c3400:	1085883a 	add	r2,r2,r2
   c3404:	10c5883a 	add	r2,r2,r3
   c3408:	100490ba 	slli	r2,r2,2
   c340c:	00c00334 	movhi	r3,12
   c3410:	10c7883a 	add	r3,r2,r3
   c3414:	18d0af17 	ldw	r3,17084(r3)
   c3418:	e0bffe17 	ldw	r2,-8(fp)
   c341c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   c3420:	e0ffff17 	ldw	r3,-4(fp)
   c3424:	1805883a 	mov	r2,r3
   c3428:	1085883a 	add	r2,r2,r2
   c342c:	10c5883a 	add	r2,r2,r3
   c3430:	100490ba 	slli	r2,r2,2
   c3434:	00c00334 	movhi	r3,12
   c3438:	10c7883a 	add	r3,r2,r3
   c343c:	18d0b017 	ldw	r3,17088(r3)
   c3440:	e0bffe17 	ldw	r2,-8(fp)
   c3444:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   c3448:	e0ffff17 	ldw	r3,-4(fp)
   c344c:	1805883a 	mov	r2,r3
   c3450:	1085883a 	add	r2,r2,r2
   c3454:	10c5883a 	add	r2,r2,r3
   c3458:	100490ba 	slli	r2,r2,2
   c345c:	00c00334 	movhi	r3,12
   c3460:	10c7883a 	add	r3,r2,r3
   c3464:	18d0b117 	ldw	r3,17092(r3)
   c3468:	e0bffe17 	ldw	r2,-8(fp)
   c346c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   c3470:	e13fff17 	ldw	r4,-4(fp)
   c3474:	00c39040 	call	c3904 <alt_release_fd>
  }
} 
   c3478:	0001883a 	nop
   c347c:	e037883a 	mov	sp,fp
   c3480:	dfc00117 	ldw	ra,4(sp)
   c3484:	df000017 	ldw	fp,0(sp)
   c3488:	dec00204 	addi	sp,sp,8
   c348c:	f800283a 	ret

000c3490 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   c3490:	defffb04 	addi	sp,sp,-20
   c3494:	dfc00415 	stw	ra,16(sp)
   c3498:	df000315 	stw	fp,12(sp)
   c349c:	df000304 	addi	fp,sp,12
   c34a0:	e13fff15 	stw	r4,-4(fp)
   c34a4:	e17ffe15 	stw	r5,-8(fp)
   c34a8:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   c34ac:	01c07fc4 	movi	r7,511
   c34b0:	01800044 	movi	r6,1
   c34b4:	e17fff17 	ldw	r5,-4(fp)
   c34b8:	01000334 	movhi	r4,12
   c34bc:	2110b204 	addi	r4,r4,17096
   c34c0:	00c33bc0 	call	c33bc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   c34c4:	01c07fc4 	movi	r7,511
   c34c8:	000d883a 	mov	r6,zero
   c34cc:	e17ffe17 	ldw	r5,-8(fp)
   c34d0:	01000334 	movhi	r4,12
   c34d4:	2110af04 	addi	r4,r4,17084
   c34d8:	00c33bc0 	call	c33bc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   c34dc:	01c07fc4 	movi	r7,511
   c34e0:	01800044 	movi	r6,1
   c34e4:	e17ffd17 	ldw	r5,-12(fp)
   c34e8:	01000334 	movhi	r4,12
   c34ec:	2110b504 	addi	r4,r4,17108
   c34f0:	00c33bc0 	call	c33bc <alt_open_fd>
}  
   c34f4:	0001883a 	nop
   c34f8:	e037883a 	mov	sp,fp
   c34fc:	dfc00117 	ldw	ra,4(sp)
   c3500:	df000017 	ldw	fp,0(sp)
   c3504:	dec00204 	addi	sp,sp,8
   c3508:	f800283a 	ret

000c350c <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
   c350c:	defff004 	addi	sp,sp,-64
   c3510:	df000f15 	stw	fp,60(sp)
   c3514:	df000f04 	addi	fp,sp,60
   c3518:	e13ff315 	stw	r4,-52(fp)
   c351c:	e17ff215 	stw	r5,-56(fp)
   c3520:	e1bff115 	stw	r6,-60(fp)
  int rc = -EINVAL;  
   c3524:	00bffa84 	movi	r2,-22
   c3528:	e0bfff15 	stw	r2,-4(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   c352c:	e0bff317 	ldw	r2,-52(fp)
   c3530:	10800828 	cmpgeui	r2,r2,32
   c3534:	1000501e 	bne	r2,zero,c3678 <alt_irq_register+0x16c>
  NIOS2_READ_STATUS (context);
   c3538:	0005303a 	rdctl	r2,status
   c353c:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c3540:	e0fffd17 	ldw	r3,-12(fp)
   c3544:	00bfff84 	movi	r2,-2
   c3548:	1884703a 	and	r2,r3,r2
   c354c:	1001703a 	wrctl	status,r2
  return context;
   c3550:	e0bffd17 	ldw	r2,-12(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
   c3554:	e0bffe15 	stw	r2,-8(fp)

    alt_irq[id].handler = handler;
   c3558:	e0bff317 	ldw	r2,-52(fp)
   c355c:	100890fa 	slli	r4,r2,3
   c3560:	e0fff117 	ldw	r3,-60(fp)
   c3564:	00800334 	movhi	r2,12
   c3568:	2085883a 	add	r2,r4,r2
   c356c:	10d1db15 	stw	r3,18284(r2)
    alt_irq[id].context = context;
   c3570:	e0bff317 	ldw	r2,-52(fp)
   c3574:	100890fa 	slli	r4,r2,3
   c3578:	e0fff217 	ldw	r3,-56(fp)
   c357c:	00800334 	movhi	r2,12
   c3580:	2085883a 	add	r2,r4,r2
   c3584:	10d1dc15 	stw	r3,18288(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
   c3588:	e0bff117 	ldw	r2,-60(fp)
   c358c:	10001a26 	beq	r2,zero,c35f8 <alt_irq_register+0xec>
   c3590:	e0bff317 	ldw	r2,-52(fp)
   c3594:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_READ_STATUS (context);
   c3598:	0005303a 	rdctl	r2,status
   c359c:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c35a0:	e0fffb17 	ldw	r3,-20(fp)
   c35a4:	00bfff84 	movi	r2,-2
   c35a8:	1884703a 	and	r2,r3,r2
   c35ac:	1001703a 	wrctl	status,r2
  return context;
   c35b0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   c35b4:	e0bffa15 	stw	r2,-24(fp)

  alt_irq_active |= (1 << id);
   c35b8:	00c00044 	movi	r3,1
   c35bc:	e0bffc17 	ldw	r2,-16(fp)
   c35c0:	1884983a 	sll	r2,r3,r2
   c35c4:	1007883a 	mov	r3,r2
   c35c8:	d0a0c817 	ldw	r2,-31968(gp)
   c35cc:	1884b03a 	or	r2,r3,r2
   c35d0:	d0a0c815 	stw	r2,-31968(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   c35d4:	d0a0c817 	ldw	r2,-31968(gp)
   c35d8:	100170fa 	wrctl	ienable,r2
   c35dc:	e0bffa17 	ldw	r2,-24(fp)
   c35e0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context);
   c35e4:	e0bff917 	ldw	r2,-28(fp)
   c35e8:	1001703a 	wrctl	status,r2
}
   c35ec:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
   c35f0:	0005883a 	mov	r2,zero
   c35f4:	00001a06 	br	c3660 <alt_irq_register+0x154>
   c35f8:	e0bff317 	ldw	r2,-52(fp)
   c35fc:	e0bff815 	stw	r2,-32(fp)
  NIOS2_READ_STATUS (context);
   c3600:	0005303a 	rdctl	r2,status
   c3604:	e0bff715 	stw	r2,-36(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   c3608:	e0fff717 	ldw	r3,-36(fp)
   c360c:	00bfff84 	movi	r2,-2
   c3610:	1884703a 	and	r2,r3,r2
   c3614:	1001703a 	wrctl	status,r2
  return context;
   c3618:	e0bff717 	ldw	r2,-36(fp)
  status = alt_irq_disable_all ();
   c361c:	e0bff615 	stw	r2,-40(fp)
  alt_irq_active &= ~(1 << id);
   c3620:	00c00044 	movi	r3,1
   c3624:	e0bff817 	ldw	r2,-32(fp)
   c3628:	1884983a 	sll	r2,r3,r2
   c362c:	0084303a 	nor	r2,zero,r2
   c3630:	1007883a 	mov	r3,r2
   c3634:	d0a0c817 	ldw	r2,-31968(gp)
   c3638:	1884703a 	and	r2,r3,r2
   c363c:	d0a0c815 	stw	r2,-31968(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   c3640:	d0a0c817 	ldw	r2,-31968(gp)
   c3644:	100170fa 	wrctl	ienable,r2
   c3648:	e0bff617 	ldw	r2,-40(fp)
   c364c:	e0bff515 	stw	r2,-44(fp)
  NIOS2_WRITE_STATUS (context);
   c3650:	e0bff517 	ldw	r2,-44(fp)
   c3654:	1001703a 	wrctl	status,r2
}
   c3658:	0001883a 	nop
  return 0;
   c365c:	0005883a 	mov	r2,zero
   c3660:	e0bfff15 	stw	r2,-4(fp)
   c3664:	e0bffe17 	ldw	r2,-8(fp)
   c3668:	e0bff415 	stw	r2,-48(fp)
  NIOS2_WRITE_STATUS (context);
   c366c:	e0bff417 	ldw	r2,-48(fp)
   c3670:	1001703a 	wrctl	status,r2
}
   c3674:	0001883a 	nop

    alt_irq_enable_all(status);
  }
  return rc; 
   c3678:	e0bfff17 	ldw	r2,-4(fp)
}
   c367c:	e037883a 	mov	sp,fp
   c3680:	df000017 	ldw	fp,0(sp)
   c3684:	dec00104 	addi	sp,sp,4
   c3688:	f800283a 	ret

000c368c <alt_get_errno>:
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   c368c:	defffe04 	addi	sp,sp,-8
   c3690:	dfc00115 	stw	ra,4(sp)
   c3694:	df000015 	stw	fp,0(sp)
   c3698:	d839883a 	mov	fp,sp
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   c369c:	d0a00917 	ldw	r2,-32732(gp)
   c36a0:	10000326 	beq	r2,zero,c36b0 <alt_get_errno+0x24>
   c36a4:	d0a00917 	ldw	r2,-32732(gp)
   c36a8:	103ee83a 	callr	r2
   c36ac:	00000106 	br	c36b4 <alt_get_errno+0x28>
   c36b0:	d0a0c104 	addi	r2,gp,-31996
        (&alt_fd_list[i] != fd))
   c36b4:	e037883a 	mov	sp,fp
   c36b8:	dfc00117 	ldw	ra,4(sp)
   c36bc:	df000017 	ldw	fp,0(sp)
   c36c0:	dec00204 	addi	sp,sp,8
   c36c4:	f800283a 	ret

000c36c8 <alt_file_locked>:
{
   c36c8:	defffd04 	addi	sp,sp,-12
   c36cc:	df000215 	stw	fp,8(sp)
   c36d0:	df000204 	addi	fp,sp,8
   c36d4:	e13ffe15 	stw	r4,-8(fp)
  fd->fd_flags |= ALT_FD_DEV;
   c36d8:	e0bffe17 	ldw	r2,-8(fp)
   c36dc:	10800217 	ldw	r2,8(r2)
   c36e0:	10d00034 	orhi	r3,r2,16384
   c36e4:	e0bffe17 	ldw	r2,-8(fp)
   c36e8:	10c00215 	stw	r3,8(r2)
  for (i = 0; i <= alt_max_fd; i++)
   c36ec:	e03fff15 	stw	zero,-4(fp)
   c36f0:	00002306 	br	c3780 <alt_file_locked+0xb8>
    if ((alt_fd_list[i].dev == fd->dev) &&
   c36f4:	e0ffff17 	ldw	r3,-4(fp)
   c36f8:	1805883a 	mov	r2,r3
   c36fc:	1085883a 	add	r2,r2,r2
   c3700:	10c5883a 	add	r2,r2,r3
   c3704:	100490ba 	slli	r2,r2,2
   c3708:	00c00334 	movhi	r3,12
   c370c:	10c7883a 	add	r3,r2,r3
   c3710:	18d0af17 	ldw	r3,17084(r3)
   c3714:	e0bffe17 	ldw	r2,-8(fp)
   c3718:	10800017 	ldw	r2,0(r2)
   c371c:	1880151e 	bne	r3,r2,c3774 <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   c3720:	e0ffff17 	ldw	r3,-4(fp)
   c3724:	1805883a 	mov	r2,r3
   c3728:	1085883a 	add	r2,r2,r2
   c372c:	10c5883a 	add	r2,r2,r3
   c3730:	100490ba 	slli	r2,r2,2
   c3734:	00c00334 	movhi	r3,12
   c3738:	10c7883a 	add	r3,r2,r3
   c373c:	1890b117 	ldw	r2,17092(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
   c3740:	10000c0e 	bge	r2,zero,c3774 <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
   c3744:	e0ffff17 	ldw	r3,-4(fp)
   c3748:	1805883a 	mov	r2,r3
   c374c:	1085883a 	add	r2,r2,r2
   c3750:	10c5883a 	add	r2,r2,r3
   c3754:	100490ba 	slli	r2,r2,2
   c3758:	00c00334 	movhi	r3,12
   c375c:	18d0af04 	addi	r3,r3,17084
   c3760:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   c3764:	e0fffe17 	ldw	r3,-8(fp)
   c3768:	18800226 	beq	r3,r2,c3774 <alt_file_locked+0xac>
    {
      return -EACCES;
   c376c:	00bffcc4 	movi	r2,-13
   c3770:	00000806 	br	c3794 <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
   c3774:	e0bfff17 	ldw	r2,-4(fp)
   c3778:	10800044 	addi	r2,r2,1
   c377c:	e0bfff15 	stw	r2,-4(fp)
   c3780:	d0a00817 	ldw	r2,-32736(gp)
   c3784:	1007883a 	mov	r3,r2
   c3788:	e0bfff17 	ldw	r2,-4(fp)
   c378c:	18bfd92e 	bgeu	r3,r2,c36f4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   c3790:	0005883a 	mov	r2,zero
}
   c3794:	e037883a 	mov	sp,fp
   c3798:	df000017 	ldw	fp,0(sp)
   c379c:	dec00104 	addi	sp,sp,4
   c37a0:	f800283a 	ret

000c37a4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   c37a4:	defff604 	addi	sp,sp,-40
   c37a8:	dfc00915 	stw	ra,36(sp)
   c37ac:	df000815 	stw	fp,32(sp)
   c37b0:	df000804 	addi	fp,sp,32
   c37b4:	e13ffa15 	stw	r4,-24(fp)
   c37b8:	e17ff915 	stw	r5,-28(fp)
   c37bc:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   c37c0:	00bfffc4 	movi	r2,-1
   c37c4:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
   c37c8:	00bffb44 	movi	r2,-19
   c37cc:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
   c37d0:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   c37d4:	d1600604 	addi	r5,gp,-32744
   c37d8:	e13ffa17 	ldw	r4,-24(fp)
   c37dc:	00c330c0 	call	c330c <alt_find_dev>
   c37e0:	e0bfff15 	stw	r2,-4(fp)
   c37e4:	e0bfff17 	ldw	r2,-4(fp)
   c37e8:	1000051e 	bne	r2,zero,c3800 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   c37ec:	e13ffa17 	ldw	r4,-24(fp)
   c37f0:	00c39980 	call	c3998 <alt_find_file>
   c37f4:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
   c37f8:	00800044 	movi	r2,1
   c37fc:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   c3800:	e0bfff17 	ldw	r2,-4(fp)
   c3804:	10002c26 	beq	r2,zero,c38b8 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
   c3808:	e13fff17 	ldw	r4,-4(fp)
   c380c:	00c3aa00 	call	c3aa0 <alt_get_fd>
   c3810:	e0bffe15 	stw	r2,-8(fp)
   c3814:	e0bffe17 	ldw	r2,-8(fp)
   c3818:	1000030e 	bge	r2,zero,c3828 <open+0x84>
    {
      status = index;
   c381c:	e0bffe17 	ldw	r2,-8(fp)
   c3820:	e0bffd15 	stw	r2,-12(fp)
   c3824:	00002606 	br	c38c0 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
   c3828:	e0fffe17 	ldw	r3,-8(fp)
   c382c:	1805883a 	mov	r2,r3
   c3830:	1085883a 	add	r2,r2,r2
   c3834:	10c5883a 	add	r2,r2,r3
   c3838:	100490ba 	slli	r2,r2,2
   c383c:	00c00334 	movhi	r3,12
   c3840:	18d0af04 	addi	r3,r3,17084
   c3844:	10c5883a 	add	r2,r2,r3
   c3848:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   c384c:	e0fff917 	ldw	r3,-28(fp)
   c3850:	00900034 	movhi	r2,16384
   c3854:	10bfffc4 	addi	r2,r2,-1
   c3858:	1886703a 	and	r3,r3,r2
   c385c:	e0bffb17 	ldw	r2,-20(fp)
   c3860:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   c3864:	e0bffc17 	ldw	r2,-16(fp)
   c3868:	1000051e 	bne	r2,zero,c3880 <open+0xdc>
   c386c:	e13ffb17 	ldw	r4,-20(fp)
   c3870:	00c36c80 	call	c36c8 <alt_file_locked>
   c3874:	e0bffd15 	stw	r2,-12(fp)
   c3878:	e0bffd17 	ldw	r2,-12(fp)
   c387c:	10001016 	blt	r2,zero,c38c0 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   c3880:	e0bfff17 	ldw	r2,-4(fp)
   c3884:	10800317 	ldw	r2,12(r2)
   c3888:	10000826 	beq	r2,zero,c38ac <open+0x108>
   c388c:	e0bfff17 	ldw	r2,-4(fp)
   c3890:	10800317 	ldw	r2,12(r2)
   c3894:	e1fff817 	ldw	r7,-32(fp)
   c3898:	e1bff917 	ldw	r6,-28(fp)
   c389c:	e17ffa17 	ldw	r5,-24(fp)
   c38a0:	e13ffb17 	ldw	r4,-20(fp)
   c38a4:	103ee83a 	callr	r2
   c38a8:	00000106 	br	c38b0 <open+0x10c>
   c38ac:	0005883a 	mov	r2,zero
   c38b0:	e0bffd15 	stw	r2,-12(fp)
   c38b4:	00000206 	br	c38c0 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
   c38b8:	00bffb44 	movi	r2,-19
   c38bc:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   c38c0:	e0bffd17 	ldw	r2,-12(fp)
   c38c4:	1000090e 	bge	r2,zero,c38ec <open+0x148>
  {
    alt_release_fd (index);  
   c38c8:	e13ffe17 	ldw	r4,-8(fp)
   c38cc:	00c39040 	call	c3904 <alt_release_fd>
    ALT_ERRNO = -status;
   c38d0:	00c368c0 	call	c368c <alt_get_errno>
   c38d4:	1007883a 	mov	r3,r2
   c38d8:	e0bffd17 	ldw	r2,-12(fp)
   c38dc:	0085c83a 	sub	r2,zero,r2
   c38e0:	18800015 	stw	r2,0(r3)
    return -1;
   c38e4:	00bfffc4 	movi	r2,-1
   c38e8:	00000106 	br	c38f0 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
   c38ec:	e0bffe17 	ldw	r2,-8(fp)
}
   c38f0:	e037883a 	mov	sp,fp
   c38f4:	dfc00117 	ldw	ra,4(sp)
   c38f8:	df000017 	ldw	fp,0(sp)
   c38fc:	dec00204 	addi	sp,sp,8
   c3900:	f800283a 	ret

000c3904 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   c3904:	defffe04 	addi	sp,sp,-8
   c3908:	df000115 	stw	fp,4(sp)
   c390c:	df000104 	addi	fp,sp,4
   c3910:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   c3914:	e0bfff17 	ldw	r2,-4(fp)
   c3918:	108000d0 	cmplti	r2,r2,3
   c391c:	1000101e 	bne	r2,zero,c3960 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
   c3920:	e0ffff17 	ldw	r3,-4(fp)
   c3924:	1805883a 	mov	r2,r3
   c3928:	1085883a 	add	r2,r2,r2
   c392c:	10c5883a 	add	r2,r2,r3
   c3930:	100490ba 	slli	r2,r2,2
   c3934:	00c00334 	movhi	r3,12
   c3938:	10c7883a 	add	r3,r2,r3
   c393c:	1810b115 	stw	zero,17092(r3)
    alt_fd_list[fd].dev      = 0;
   c3940:	e0ffff17 	ldw	r3,-4(fp)
   c3944:	1805883a 	mov	r2,r3
   c3948:	1085883a 	add	r2,r2,r2
   c394c:	10c5883a 	add	r2,r2,r3
   c3950:	100490ba 	slli	r2,r2,2
   c3954:	00c00334 	movhi	r3,12
   c3958:	10c7883a 	add	r3,r2,r3
   c395c:	1810af15 	stw	zero,17084(r3)
  }
}
   c3960:	0001883a 	nop
   c3964:	e037883a 	mov	sp,fp
   c3968:	df000017 	ldw	fp,0(sp)
   c396c:	dec00104 	addi	sp,sp,4
   c3970:	f800283a 	ret

000c3974 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
   c3974:	deffff04 	addi	sp,sp,-4
   c3978:	df000015 	stw	fp,0(sp)
   c397c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   c3980:	000170fa 	wrctl	ienable,zero
}
   c3984:	0001883a 	nop
   c3988:	e037883a 	mov	sp,fp
   c398c:	df000017 	ldw	fp,0(sp)
   c3990:	dec00104 	addi	sp,sp,4
   c3994:	f800283a 	ret

000c3998 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   c3998:	defffb04 	addi	sp,sp,-20
   c399c:	dfc00415 	stw	ra,16(sp)
   c39a0:	df000315 	stw	fp,12(sp)
   c39a4:	df000304 	addi	fp,sp,12
   c39a8:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   c39ac:	d0a00417 	ldw	r2,-32752(gp)
   c39b0:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   c39b4:	00003106 	br	c3a7c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
   c39b8:	e0bfff17 	ldw	r2,-4(fp)
   c39bc:	10800217 	ldw	r2,8(r2)
   c39c0:	1009883a 	mov	r4,r2
   c39c4:	00c0f4c0 	call	c0f4c <strlen>
   c39c8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   c39cc:	e0bfff17 	ldw	r2,-4(fp)
   c39d0:	10c00217 	ldw	r3,8(r2)
   c39d4:	e0bffe17 	ldw	r2,-8(fp)
   c39d8:	10bfffc4 	addi	r2,r2,-1
   c39dc:	1885883a 	add	r2,r3,r2
   c39e0:	10800003 	ldbu	r2,0(r2)
   c39e4:	10803fcc 	andi	r2,r2,255
   c39e8:	1080201c 	xori	r2,r2,128
   c39ec:	10bfe004 	addi	r2,r2,-128
   c39f0:	10800bd8 	cmpnei	r2,r2,47
   c39f4:	1000031e 	bne	r2,zero,c3a04 <alt_find_file+0x6c>
    {
      len -= 1;
   c39f8:	e0bffe17 	ldw	r2,-8(fp)
   c39fc:	10bfffc4 	addi	r2,r2,-1
   c3a00:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   c3a04:	e0bffe17 	ldw	r2,-8(fp)
   c3a08:	e0fffd17 	ldw	r3,-12(fp)
   c3a0c:	1885883a 	add	r2,r3,r2
   c3a10:	10800003 	ldbu	r2,0(r2)
   c3a14:	10803fcc 	andi	r2,r2,255
   c3a18:	1080201c 	xori	r2,r2,128
   c3a1c:	10bfe004 	addi	r2,r2,-128
   c3a20:	10800be0 	cmpeqi	r2,r2,47
   c3a24:	1000081e 	bne	r2,zero,c3a48 <alt_find_file+0xb0>
   c3a28:	e0bffe17 	ldw	r2,-8(fp)
   c3a2c:	e0fffd17 	ldw	r3,-12(fp)
   c3a30:	1885883a 	add	r2,r3,r2
   c3a34:	10800003 	ldbu	r2,0(r2)
   c3a38:	10803fcc 	andi	r2,r2,255
   c3a3c:	1080201c 	xori	r2,r2,128
   c3a40:	10bfe004 	addi	r2,r2,-128
   c3a44:	10000a1e 	bne	r2,zero,c3a70 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
   c3a48:	e0bfff17 	ldw	r2,-4(fp)
   c3a4c:	10800217 	ldw	r2,8(r2)
   c3a50:	e0fffe17 	ldw	r3,-8(fp)
   c3a54:	180d883a 	mov	r6,r3
   c3a58:	e17ffd17 	ldw	r5,-12(fp)
   c3a5c:	1009883a 	mov	r4,r2
   c3a60:	00c3c000 	call	c3c00 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
   c3a64:	1000021e 	bne	r2,zero,c3a70 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
   c3a68:	e0bfff17 	ldw	r2,-4(fp)
   c3a6c:	00000706 	br	c3a8c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
   c3a70:	e0bfff17 	ldw	r2,-4(fp)
   c3a74:	10800017 	ldw	r2,0(r2)
   c3a78:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
   c3a7c:	e0ffff17 	ldw	r3,-4(fp)
   c3a80:	d0a00404 	addi	r2,gp,-32752
   c3a84:	18bfcc1e 	bne	r3,r2,c39b8 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
   c3a88:	0005883a 	mov	r2,zero
}
   c3a8c:	e037883a 	mov	sp,fp
   c3a90:	dfc00117 	ldw	ra,4(sp)
   c3a94:	df000017 	ldw	fp,0(sp)
   c3a98:	dec00204 	addi	sp,sp,8
   c3a9c:	f800283a 	ret

000c3aa0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   c3aa0:	defffc04 	addi	sp,sp,-16
   c3aa4:	df000315 	stw	fp,12(sp)
   c3aa8:	df000304 	addi	fp,sp,12
   c3aac:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
   c3ab0:	00bffa04 	movi	r2,-24
   c3ab4:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   c3ab8:	e03fff15 	stw	zero,-4(fp)
   c3abc:	00001d06 	br	c3b34 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   c3ac0:	e0ffff17 	ldw	r3,-4(fp)
   c3ac4:	1805883a 	mov	r2,r3
   c3ac8:	1085883a 	add	r2,r2,r2
   c3acc:	10c5883a 	add	r2,r2,r3
   c3ad0:	100490ba 	slli	r2,r2,2
   c3ad4:	00c00334 	movhi	r3,12
   c3ad8:	10c7883a 	add	r3,r2,r3
   c3adc:	1890af17 	ldw	r2,17084(r3)
   c3ae0:	1000111e 	bne	r2,zero,c3b28 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   c3ae4:	e0ffff17 	ldw	r3,-4(fp)
   c3ae8:	1805883a 	mov	r2,r3
   c3aec:	1085883a 	add	r2,r2,r2
   c3af0:	10c5883a 	add	r2,r2,r3
   c3af4:	100490ba 	slli	r2,r2,2
   c3af8:	e13ffd17 	ldw	r4,-12(fp)
   c3afc:	00c00334 	movhi	r3,12
   c3b00:	10c7883a 	add	r3,r2,r3
   c3b04:	1910af15 	stw	r4,17084(r3)
      if (i > alt_max_fd)
   c3b08:	d0e00817 	ldw	r3,-32736(gp)
   c3b0c:	e0bfff17 	ldw	r2,-4(fp)
   c3b10:	1880020e 	bge	r3,r2,c3b1c <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   c3b14:	e0bfff17 	ldw	r2,-4(fp)
   c3b18:	d0a00815 	stw	r2,-32736(gp)
      }
      rc = i;
   c3b1c:	e0bfff17 	ldw	r2,-4(fp)
   c3b20:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   c3b24:	00000706 	br	c3b44 <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
   c3b28:	e0bfff17 	ldw	r2,-4(fp)
   c3b2c:	10800044 	addi	r2,r2,1
   c3b30:	e0bfff15 	stw	r2,-4(fp)
   c3b34:	e0bfff17 	ldw	r2,-4(fp)
   c3b38:	10800810 	cmplti	r2,r2,32
   c3b3c:	103fe01e 	bne	r2,zero,c3ac0 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
   c3b40:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   c3b44:	e0bffe17 	ldw	r2,-8(fp)
}
   c3b48:	e037883a 	mov	sp,fp
   c3b4c:	df000017 	ldw	fp,0(sp)
   c3b50:	dec00104 	addi	sp,sp,4
   c3b54:	f800283a 	ret

000c3b58 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   c3b58:	defffe04 	addi	sp,sp,-8
   c3b5c:	df000115 	stw	fp,4(sp)
   c3b60:	df000104 	addi	fp,sp,4
   c3b64:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   c3b68:	e0bfff17 	ldw	r2,-4(fp)
   c3b6c:	10bffe84 	addi	r2,r2,-6
   c3b70:	10c00428 	cmpgeui	r3,r2,16
   c3b74:	18c03fcc 	andi	r3,r3,255
   c3b78:	18000f1e 	bne	r3,zero,c3bb8 <alt_exception_cause_generated_bad_addr+0x60>
   c3b7c:	00c00044 	movi	r3,1
   c3b80:	1884983a 	sll	r2,r3,r2
   c3b84:	10e2c8cc 	andi	r3,r2,35619
   c3b88:	1806c03a 	cmpne	r3,r3,zero
   c3b8c:	18c03fcc 	andi	r3,r3,255
   c3b90:	1800051e 	bne	r3,zero,c3ba8 <alt_exception_cause_generated_bad_addr+0x50>
   c3b94:	1084100c 	andi	r2,r2,4160
   c3b98:	1004c03a 	cmpne	r2,r2,zero
   c3b9c:	10803fcc 	andi	r2,r2,255
   c3ba0:	1000031e 	bne	r2,zero,c3bb0 <alt_exception_cause_generated_bad_addr+0x58>
   c3ba4:	00000406 	br	c3bb8 <alt_exception_cause_generated_bad_addr+0x60>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   c3ba8:	00800044 	movi	r2,1
   c3bac:	00000306 	br	c3bbc <alt_exception_cause_generated_bad_addr+0x64>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   c3bb0:	0005883a 	mov	r2,zero
   c3bb4:	00000106 	br	c3bbc <alt_exception_cause_generated_bad_addr+0x64>

  default:
    return 0;
   c3bb8:	0005883a 	mov	r2,zero
  }
}
   c3bbc:	e037883a 	mov	sp,fp
   c3bc0:	df000017 	ldw	fp,0(sp)
   c3bc4:	dec00104 	addi	sp,sp,4
   c3bc8:	f800283a 	ret

000c3bcc <atexit>:
   c3bcc:	200b883a 	mov	r5,r4
   c3bd0:	000f883a 	mov	r7,zero
   c3bd4:	000d883a 	mov	r6,zero
   c3bd8:	0009883a 	mov	r4,zero
   c3bdc:	00c3c301 	jmpi	c3c30 <__register_exitproc>

000c3be0 <exit>:
   c3be0:	defffe04 	addi	sp,sp,-8
   c3be4:	000b883a 	mov	r5,zero
   c3be8:	dc000015 	stw	r16,0(sp)
   c3bec:	dfc00115 	stw	ra,4(sp)
   c3bf0:	2021883a 	mov	r16,r4
   c3bf4:	00c3d580 	call	c3d58 <__call_exitprocs>
   c3bf8:	8009883a 	mov	r4,r16
   c3bfc:	00c3e840 	call	c3e84 <_exit>

000c3c00 <memcmp>:
   c3c00:	0007883a 	mov	r3,zero
   c3c04:	30c0021e 	bne	r6,r3,c3c10 <memcmp+0x10>
   c3c08:	0005883a 	mov	r2,zero
   c3c0c:	f800283a 	ret
   c3c10:	20c5883a 	add	r2,r4,r3
   c3c14:	18c00044 	addi	r3,r3,1
   c3c18:	28cf883a 	add	r7,r5,r3
   c3c1c:	10800003 	ldbu	r2,0(r2)
   c3c20:	39ffffc3 	ldbu	r7,-1(r7)
   c3c24:	11fff726 	beq	r2,r7,c3c04 <memcmp+0x4>
   c3c28:	11c5c83a 	sub	r2,r2,r7
   c3c2c:	f800283a 	ret

000c3c30 <__register_exitproc>:
   c3c30:	defffa04 	addi	sp,sp,-24
   c3c34:	00800334 	movhi	r2,12
   c3c38:	dc000015 	stw	r16,0(sp)
   c3c3c:	1411da17 	ldw	r16,18280(r2)
   c3c40:	dd000415 	stw	r20,16(sp)
   c3c44:	dcc00315 	stw	r19,12(sp)
   c3c48:	dc800215 	stw	r18,8(sp)
   c3c4c:	dc400115 	stw	r17,4(sp)
   c3c50:	dfc00515 	stw	ra,20(sp)
   c3c54:	2023883a 	mov	r17,r4
   c3c58:	2825883a 	mov	r18,r5
   c3c5c:	3029883a 	mov	r20,r6
   c3c60:	3827883a 	mov	r19,r7
   c3c64:	80000c1e 	bne	r16,zero,c3c98 <__register_exitproc+0x68>
   c3c68:	00800334 	movhi	r2,12
   c3c6c:	00c00334 	movhi	r3,12
   c3c70:	10921b04 	addi	r2,r2,18540
   c3c74:	1891da15 	stw	r2,18280(r3)
   c3c78:	00c00034 	movhi	r3,0
   c3c7c:	18c00004 	addi	r3,r3,0
   c3c80:	18000326 	beq	r3,zero,c3c90 <__register_exitproc+0x60>
   c3c84:	00c00034 	movhi	r3,0
   c3c88:	18c00017 	ldw	r3,0(r3)
   c3c8c:	10c02215 	stw	r3,136(r2)
   c3c90:	04000334 	movhi	r16,12
   c3c94:	84121b04 	addi	r16,r16,18540
   c3c98:	80800117 	ldw	r2,4(r16)
   c3c9c:	10800810 	cmplti	r2,r2,32
   c3ca0:	1000091e 	bne	r2,zero,c3cc8 <__register_exitproc+0x98>
   c3ca4:	00bfffc4 	movi	r2,-1
   c3ca8:	dfc00517 	ldw	ra,20(sp)
   c3cac:	dd000417 	ldw	r20,16(sp)
   c3cb0:	dcc00317 	ldw	r19,12(sp)
   c3cb4:	dc800217 	ldw	r18,8(sp)
   c3cb8:	dc400117 	ldw	r17,4(sp)
   c3cbc:	dc000017 	ldw	r16,0(sp)
   c3cc0:	dec00604 	addi	sp,sp,24
   c3cc4:	f800283a 	ret
   c3cc8:	88001a26 	beq	r17,zero,c3d34 <__register_exitproc+0x104>
   c3ccc:	80802217 	ldw	r2,136(r16)
   c3cd0:	1000091e 	bne	r2,zero,c3cf8 <__register_exitproc+0xc8>
   c3cd4:	00800034 	movhi	r2,0
   c3cd8:	10800004 	addi	r2,r2,0
   c3cdc:	103ff126 	beq	r2,zero,c3ca4 <__register_exitproc+0x74>
   c3ce0:	01004204 	movi	r4,264
   c3ce4:	00000000 	call	0 <__alt_mem_audio_rom>
   c3ce8:	103fee26 	beq	r2,zero,c3ca4 <__register_exitproc+0x74>
   c3cec:	10004015 	stw	zero,256(r2)
   c3cf0:	10004115 	stw	zero,260(r2)
   c3cf4:	80802215 	stw	r2,136(r16)
   c3cf8:	81400117 	ldw	r5,4(r16)
   c3cfc:	00c00044 	movi	r3,1
   c3d00:	8c400098 	cmpnei	r17,r17,2
   c3d04:	280890ba 	slli	r4,r5,2
   c3d08:	1946983a 	sll	r3,r3,r5
   c3d0c:	1109883a 	add	r4,r2,r4
   c3d10:	25000015 	stw	r20,0(r4)
   c3d14:	11404017 	ldw	r5,256(r2)
   c3d18:	28cab03a 	or	r5,r5,r3
   c3d1c:	11404015 	stw	r5,256(r2)
   c3d20:	24c02015 	stw	r19,128(r4)
   c3d24:	8800031e 	bne	r17,zero,c3d34 <__register_exitproc+0x104>
   c3d28:	11004117 	ldw	r4,260(r2)
   c3d2c:	20c6b03a 	or	r3,r4,r3
   c3d30:	10c04115 	stw	r3,260(r2)
   c3d34:	80800117 	ldw	r2,4(r16)
   c3d38:	10c00044 	addi	r3,r2,1
   c3d3c:	10800084 	addi	r2,r2,2
   c3d40:	100490ba 	slli	r2,r2,2
   c3d44:	80c00115 	stw	r3,4(r16)
   c3d48:	80a1883a 	add	r16,r16,r2
   c3d4c:	84800015 	stw	r18,0(r16)
   c3d50:	0005883a 	mov	r2,zero
   c3d54:	003fd406 	br	c3ca8 <__register_exitproc+0x78>

000c3d58 <__call_exitprocs>:
   c3d58:	defff604 	addi	sp,sp,-40
   c3d5c:	dd800615 	stw	r22,24(sp)
   c3d60:	dd400515 	stw	r21,20(sp)
   c3d64:	dd000415 	stw	r20,16(sp)
   c3d68:	dfc00915 	stw	ra,36(sp)
   c3d6c:	df000815 	stw	fp,32(sp)
   c3d70:	ddc00715 	stw	r23,28(sp)
   c3d74:	dcc00315 	stw	r19,12(sp)
   c3d78:	dc800215 	stw	r18,8(sp)
   c3d7c:	dc400115 	stw	r17,4(sp)
   c3d80:	dc000015 	stw	r16,0(sp)
   c3d84:	202b883a 	mov	r21,r4
   c3d88:	2829883a 	mov	r20,r5
   c3d8c:	05800044 	movi	r22,1
   c3d90:	00800334 	movhi	r2,12
   c3d94:	1451da17 	ldw	r17,18280(r2)
   c3d98:	88000726 	beq	r17,zero,c3db8 <__call_exitprocs+0x60>
   c3d9c:	8c000117 	ldw	r16,4(r17)
   c3da0:	8cc02217 	ldw	r19,136(r17)
   c3da4:	84bfffc4 	addi	r18,r16,-1
   c3da8:	802090ba 	slli	r16,r16,2
   c3dac:	9c2f883a 	add	r23,r19,r16
   c3db0:	8c21883a 	add	r16,r17,r16
   c3db4:	90000c0e 	bge	r18,zero,c3de8 <__call_exitprocs+0x90>
   c3db8:	dfc00917 	ldw	ra,36(sp)
   c3dbc:	df000817 	ldw	fp,32(sp)
   c3dc0:	ddc00717 	ldw	r23,28(sp)
   c3dc4:	dd800617 	ldw	r22,24(sp)
   c3dc8:	dd400517 	ldw	r21,20(sp)
   c3dcc:	dd000417 	ldw	r20,16(sp)
   c3dd0:	dcc00317 	ldw	r19,12(sp)
   c3dd4:	dc800217 	ldw	r18,8(sp)
   c3dd8:	dc400117 	ldw	r17,4(sp)
   c3ddc:	dc000017 	ldw	r16,0(sp)
   c3de0:	dec00a04 	addi	sp,sp,40
   c3de4:	f800283a 	ret
   c3de8:	a0000726 	beq	r20,zero,c3e08 <__call_exitprocs+0xb0>
   c3dec:	9800041e 	bne	r19,zero,c3e00 <__call_exitprocs+0xa8>
   c3df0:	94bfffc4 	addi	r18,r18,-1
   c3df4:	bdffff04 	addi	r23,r23,-4
   c3df8:	843fff04 	addi	r16,r16,-4
   c3dfc:	003fed06 	br	c3db4 <__call_exitprocs+0x5c>
   c3e00:	b8801f17 	ldw	r2,124(r23)
   c3e04:	153ffa1e 	bne	r2,r20,c3df0 <__call_exitprocs+0x98>
   c3e08:	88c00117 	ldw	r3,4(r17)
   c3e0c:	80800117 	ldw	r2,4(r16)
   c3e10:	18ffffc4 	addi	r3,r3,-1
   c3e14:	1c800f1e 	bne	r3,r18,c3e54 <__call_exitprocs+0xfc>
   c3e18:	8c800115 	stw	r18,4(r17)
   c3e1c:	103ff426 	beq	r2,zero,c3df0 <__call_exitprocs+0x98>
   c3e20:	8f000117 	ldw	fp,4(r17)
   c3e24:	98000426 	beq	r19,zero,c3e38 <__call_exitprocs+0xe0>
   c3e28:	b486983a 	sll	r3,r22,r18
   c3e2c:	99004017 	ldw	r4,256(r19)
   c3e30:	1908703a 	and	r4,r3,r4
   c3e34:	2000091e 	bne	r4,zero,c3e5c <__call_exitprocs+0x104>
   c3e38:	103ee83a 	callr	r2
   c3e3c:	88c00117 	ldw	r3,4(r17)
   c3e40:	00800334 	movhi	r2,12
   c3e44:	1091da17 	ldw	r2,18280(r2)
   c3e48:	1f3fd11e 	bne	r3,fp,c3d90 <__call_exitprocs+0x38>
   c3e4c:	88bfe826 	beq	r17,r2,c3df0 <__call_exitprocs+0x98>
   c3e50:	003fcf06 	br	c3d90 <__call_exitprocs+0x38>
   c3e54:	80000115 	stw	zero,4(r16)
   c3e58:	003ff006 	br	c3e1c <__call_exitprocs+0xc4>
   c3e5c:	99404117 	ldw	r5,260(r19)
   c3e60:	b93fff17 	ldw	r4,-4(r23)
   c3e64:	1946703a 	and	r3,r3,r5
   c3e68:	1800041e 	bne	r3,zero,c3e7c <__call_exitprocs+0x124>
   c3e6c:	200b883a 	mov	r5,r4
   c3e70:	a809883a 	mov	r4,r21
   c3e74:	103ee83a 	callr	r2
   c3e78:	003ff006 	br	c3e3c <__call_exitprocs+0xe4>
   c3e7c:	103ee83a 	callr	r2
   c3e80:	003fee06 	br	c3e3c <__call_exitprocs+0xe4>

000c3e84 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   c3e84:	defffd04 	addi	sp,sp,-12
   c3e88:	df000215 	stw	fp,8(sp)
   c3e8c:	df000204 	addi	fp,sp,8
   c3e90:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   c3e94:	0001883a 	nop
   c3e98:	e0bffe17 	ldw	r2,-8(fp)
   c3e9c:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
   c3ea0:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   c3ea4:	10000226 	beq	r2,zero,c3eb0 <_exit+0x2c>
    ALT_SIM_FAIL();
   c3ea8:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
   c3eac:	00000106 	br	c3eb4 <_exit+0x30>
    ALT_SIM_PASS();
   c3eb0:	002af0b0 	cmpltui	zero,zero,43970
}
   c3eb4:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   c3eb8:	0001883a 	nop
   c3ebc:	003ffe06 	br	c3eb8 <_exit+0x34>
